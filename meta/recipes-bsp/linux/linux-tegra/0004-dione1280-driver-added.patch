From 53f52886aa572e3bbd79d3eaacfa9b31e79968a5 Mon Sep 17 00:00:00 2001
From: Botond Kardos <bkardos70@gmail.com>
Date: Tue, 21 Dec 2021 15:00:30 +0100
Subject: [PATCH] dione1280 driver added

---
 nvidia/drivers/media/i2c/Kconfig              |    9 +
 nvidia/drivers/media/i2c/Makefile             |    1 +
 nvidia/drivers/media/i2c/dione1280.c          | 1355 +++++++++++++++++
 nvidia/drivers/media/i2c/tc358746_regs.h      |    2 +
 .../tegra210-camera-rbpcv2-dione1280.dtsi     |  300 ++++
 .../tegra210-camera-rbpcv2-dione640.dtsi      |   18 +-
 ...tegra210-porg-camera-rbpcv2-dione1280.dtsi |   42 +
 .../tegra210-porg-camera-rbpcv2-dione640.dtsi |    4 +-
 .../porg-platforms/tegra210-porg-camera.dtsi  |    3 +-
 .../tegra210-porg-plugin-manager.dtsi         |  141 +-
 .../tegra210-porg-p3448-common.dtsi           |    3 +-
 11 files changed, 1864 insertions(+), 14 deletions(-)
 create mode 100644 nvidia/drivers/media/i2c/dione1280.c
 create mode 100644 nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione1280.dtsi
 create mode 100644 nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione1280.dtsi

diff --git a/nvidia/drivers/media/i2c/Kconfig b/nvidia/drivers/media/i2c/Kconfig
index d39d4b0855ef..8668b551a96e 100644
--- a/nvidia/drivers/media/i2c/Kconfig
+++ b/nvidia/drivers/media/i2c/Kconfig
@@ -12,6 +12,15 @@ config VIDEO_DIONE640
 	  To compile this driver as a module, choose M here: the module
 	  will be called dione640.
 
+config VIDEO_DIONE1280
+	tristate "DIONE1280 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This driver supports DIONE1280 infra camera sensor from Xenics
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called dione1280.
+
 config VIDEO_IMX185
 	tristate "IMX185 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/nvidia/drivers/media/i2c/Makefile b/nvidia/drivers/media/i2c/Makefile
index dfd602e4b367..6155907af7ce 100644
--- a/nvidia/drivers/media/i2c/Makefile
+++ b/nvidia/drivers/media/i2c/Makefile
@@ -22,3 +22,4 @@ obj-$(CONFIG_I2C_IOEXPANDER_SER_MAX9295) += max9295.o
 obj-$(CONFIG_I2C_IOEXPANDER_DESER_MAX9296) += max9296.o
 obj-$(CONFIG_VIDEO_IMX390) += imx390.o
 obj-$(CONFIG_VIDEO_DIONE640) += dione640.o
+obj-$(CONFIG_VIDEO_DIONE1280) += dione1280.o
diff --git a/nvidia/drivers/media/i2c/dione1280.c b/nvidia/drivers/media/i2c/dione1280.c
new file mode 100644
index 000000000000..4886ce1400fe
--- /dev/null
+++ b/nvidia/drivers/media/i2c/dione1280.c
@@ -0,0 +1,1355 @@
+/*
+ * dione1280.c - dione1280 sensor driver
+ *
+ * Copyright (c) 2015-2020, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/i2c.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegracam_core.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "tc358746_regs.h"
+
+#include "../drivers/base/regmap/internal.h"
+
+
+#define DIONE1280_REG_WIDTH_MAX        0x0002f028
+#define DIONE1280_REG_HEIGHT_MAX       0x0002f02c
+#define DIONE1280_REG_MODEL_NAME       0x00000044
+#define DIONE1280_REG_FIRMWARE_VERSION 0x2000e000
+
+#define DIONE1280_I2C_TMO_MS           5
+
+
+static int test_mode = 0;
+module_param(test_mode, int, 0644);
+
+enum {
+	/* DIONE1280_MODE_640x480_60FPS, */
+	DIONE1280_MODE_1280x1024_60FPS,
+};
+
+static const int dione1280_60fps[] = {
+	60,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in
+ * device tree!
+ */
+static const struct camera_common_frmfmt dione1280_frmfmt[] = {
+	{{1280, 1024},	dione1280_60fps, 1, 0, DIONE1280_MODE_1280x1024_60FPS},
+	/* Add modes with no device tree support after below */
+};
+
+static const struct regmap_range ctl_regmap_rw_ranges[] = {
+	regmap_reg_range(0x0000, 0x00ff),
+};
+
+static const struct regmap_access_table ctl_regmap_access = {
+	.yes_ranges = ctl_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(ctl_regmap_rw_ranges),
+};
+
+static const struct regmap_config ctl_regmap_config = {
+	.reg_bits = 16,
+	.reg_stride = 2,
+	.val_bits = 16,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0x00ff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.rd_table = &ctl_regmap_access,
+	.wr_table = &ctl_regmap_access,
+	.name = "tc358746-ctl",
+};
+
+static const struct regmap_range tx_regmap_rw_ranges[] = {
+	regmap_reg_range(0x0100, 0x05ff),
+};
+
+static const struct regmap_access_table tx_regmap_access = {
+	.yes_ranges = tx_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(tx_regmap_rw_ranges),
+};
+
+static const struct regmap_config tx_regmap_config = {
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0x05ff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG_LITTLE,
+	.rd_table = &tx_regmap_access,
+	.wr_table = &tx_regmap_access,
+	.name = "tc358746-tx",
+};
+
+static const struct regmap_range dummy_regmap_rw_ranges[] = {
+	regmap_reg_range(0xc4, 0xc4),
+};
+
+static const struct regmap_access_table dummy_regmap_access = {
+	.yes_ranges = dummy_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(dummy_regmap_rw_ranges),
+};
+
+static const struct regmap_config dummy_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0xc4,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG_LITTLE,
+	.rd_table = &dummy_regmap_access,
+	.name = "tc358746-tx",
+};
+
+static const struct of_device_id dione1280_of_match[] = {
+	{ .compatible = "xenics,dione1280", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, dione1280_of_match);
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+};
+
+struct dione1280 {
+	struct i2c_client		*sens_client;
+	struct i2c_client		*tc35_client;
+	struct v4l2_subdev		*subdev;
+	struct regmap			*ctl_regmap;
+	struct regmap			*tx_regmap;
+	struct camera_common_data	*s_data;
+	struct tegracam_device		*tc_dev;
+};
+
+static inline int dione1280_read_reg(struct camera_common_data *s_data,
+	u16 addr, u8 *val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xff;
+
+	return err;
+}
+
+#define my_regmap_write2(m, r, v) my_regmap_write(__func__, __LINE__, m, r, v)
+
+static inline int my_regmap_write(const char * func, int line,
+								  struct regmap *map, unsigned int reg, unsigned int val)
+{
+    printk( KERN_ALERT "**** %s %i   regmap: %s   reg: 0x%04x    val: 0x%04x\n",
+			func, line, map->name, reg, val );
+
+	return regmap_write(map, reg, val);
+}
+
+#define my_regmap_update_bits2(m, r, msk, v) my_regmap_update_bits(__func__, __LINE__, m, r, msk, v)
+
+static inline int my_regmap_update_bits(const char * func, int line,
+										struct regmap *map, unsigned int reg,
+										unsigned int mask, unsigned int val)
+{
+    int ret1, ret2;
+	unsigned int reg_val;
+
+	ret1 = regmap_update_bits(map, reg, mask, val);
+	ret2 = regmap_read(map, reg, &reg_val);
+    printk( KERN_ALERT "**** %s %i   regmap: %s   reg: 0x%04x   val: 0x%04x    ret: %i\n",
+			func, line, map->name, reg, val, ret2 );
+
+	return ret1;
+}
+
+static inline int dione1280_write_reg(struct camera_common_data *s_data,
+	u16 addr, u8 val)
+{
+	int err = 0;
+
+    printk( KERN_ALERT "**** %s %i   addr: 0x%04x    val: 0x%02x\n",
+			__func__, __LINE__,	(int )addr, (int )val );
+
+	err = my_regmap_write2(s_data->regmap, addr, val);
+	if (err)
+		dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int dione1280_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%d\n", __func__, val);
+	return 0;
+}
+
+static int dione1280_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static int dione1280_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static int dione1280_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static struct tegracam_ctrl_ops dione1280_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.set_gain = dione1280_set_gain,
+	.set_exposure = dione1280_set_exposure,
+	.set_frame_rate = dione1280_set_frame_rate,
+	.set_group_hold = dione1280_set_group_hold,
+};
+
+static int dione1280_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 0);
+		else
+			gpio_set_value(pw->reset_gpio, 0);
+	}
+
+	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
+		goto skip_power_seqn;
+
+	usleep_range(10, 20);
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		if (err)
+			goto dione1280_avdd_fail;
+	}
+
+	if (pw->iovdd) {
+		err = regulator_enable(pw->iovdd);
+		if (err)
+			goto dione1280_iovdd_fail;
+	}
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		if (err)
+			goto dione1280_dvdd_fail;
+	}
+
+	usleep_range(10, 20);
+
+skip_power_seqn:
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 1);
+		else
+			gpio_set_value(pw->reset_gpio, 1);
+	}
+
+	usleep_range(23000, 23100);
+
+	pw->state = SWITCH_ON;
+
+	return 0;
+
+dione1280_dvdd_fail:
+	regulator_disable(pw->iovdd);
+
+dione1280_iovdd_fail:
+	regulator_disable(pw->avdd);
+
+dione1280_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+
+	return -ENODEV;
+}
+
+static int dione1280_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (err) {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	} else {
+		printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+		if (pw->reset_gpio) {
+			if (gpio_cansleep(pw->reset_gpio))
+				gpio_set_value_cansleep(pw->reset_gpio, 0);
+			else
+				gpio_set_value(pw->reset_gpio, 0);
+		}
+
+		usleep_range(10, 10);
+
+		if (pw->dvdd)
+			regulator_disable(pw->dvdd);
+		if (pw->iovdd)
+			regulator_disable(pw->iovdd);
+		if (pw->avdd)
+			regulator_disable(pw->avdd);
+	}
+
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int dione1280_power_put(struct tegracam_device *tc_dev)
+{
+	struct dione1280 *priv = (struct dione1280 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->dvdd))
+		devm_regulator_put(pw->dvdd);
+
+	if (likely(pw->avdd))
+		devm_regulator_put(pw->avdd);
+
+	if (likely(pw->iovdd))
+		devm_regulator_put(pw->iovdd);
+
+	pw->dvdd = NULL;
+	pw->avdd = NULL;
+	pw->iovdd = NULL;
+
+	if (likely(pw->reset_gpio))
+		gpio_free(pw->reset_gpio);
+
+	if (priv->tc35_client != NULL) {
+		i2c_unregister_device(priv->tc35_client);
+		priv->tc35_client = NULL;
+	}
+
+	return 0;
+}
+
+static int dione1280_power_get(struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct clk *parent;
+	int err = 0;
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	/* Sensor MCLK (aka. INCK) */
+	if (pdata->mclk_name) {
+		pw->mclk = devm_clk_get(dev, pdata->mclk_name);
+		if (IS_ERR(pw->mclk)) {
+			dev_err(dev, "unable to get clock %s\n",
+				pdata->mclk_name);
+			return PTR_ERR(pw->mclk);
+		}
+
+		if (pdata->parentclk_name) {
+			parent = devm_clk_get(dev, pdata->parentclk_name);
+			if (IS_ERR(parent)) {
+				dev_err(dev, "unable to get parent clock %s",
+					pdata->parentclk_name);
+			} else
+				clk_set_parent(pw->mclk, parent);
+		}
+	}
+
+	/* analog 2.8v */
+	if (pdata->regulators.avdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->avdd, pdata->regulators.avdd);
+	/* IO 1.8v */
+	if (pdata->regulators.iovdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->iovdd, pdata->regulators.iovdd);
+	/* dig 1.2v */
+	if (pdata->regulators.dvdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->dvdd, pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "%s: unable to get regulator(s)\n", __func__);
+		goto done;
+	}
+
+	/* Reset or ENABLE GPIO */
+	pw->reset_gpio = pdata->reset_gpio;
+	err = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+	if (err < 0) {
+		dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
+			__func__, err);
+		goto done;
+	}
+
+done:
+	pw->state = SWITCH_OFF;
+
+	return err;
+}
+
+static struct camera_common_pdata *dione1280_parse_dt(
+	struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	struct camera_common_pdata *ret = NULL;
+	int err = 0;
+	int gpio;
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(dione1280_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+		sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+    printk( KERN_ALERT "**** %s %i   gpio: %i\n", __func__, __LINE__, gpio );
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER)
+			ret = ERR_PTR(-EPROBE_DEFER);
+		dev_err(dev, "reset-gpios not found\n");
+		goto error;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	err = of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
+	if (err)
+		dev_dbg(dev, "mclk name not present, "
+			"assume sensor driven externally\n");
+
+	err = of_property_read_string(np, "avdd-reg",
+		&board_priv_pdata->regulators.avdd);
+	err |= of_property_read_string(np, "iovdd-reg",
+		&board_priv_pdata->regulators.iovdd);
+	err |= of_property_read_string(np, "dvdd-reg",
+		&board_priv_pdata->regulators.dvdd);
+	if (err)
+		dev_dbg(dev, "avdd, iovdd and/or dvdd reglrs. not present, "
+			"assume sensor powered independently\n");
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(np, "has-eeprom");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+
+	return ret;
+}
+
+static inline int tc358746_sleep_mode(struct regmap *regmap, int enable)
+{
+	return my_regmap_update_bits2(regmap, SYSCTL, SYSCTL_SLEEP_MASK,
+				  enable ? SYSCTL_SLEEP_MASK : 0);
+}
+
+static inline int tc358746_sreset(struct regmap *regmap)
+{
+	int err;
+
+	err = my_regmap_write2(regmap, SYSCTL, SYSCTL_SRESET_MASK);
+
+	udelay(10);
+
+	if (!err)
+		err = my_regmap_write2(regmap, SYSCTL, 0);
+
+	return err;
+}
+
+static int tc358746_set_pll(struct regmap *regmap,
+			    u16 pll_prd, u16 pll_fbd, u16 pll_frs)
+{
+	u32 pllctl0, pllctl1, pllctl0_new;
+	int err;
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+
+	err = regmap_read(regmap, PLLCTL0, &pllctl0);
+	if (!err)
+		err = regmap_read(regmap, PLLCTL1, &pllctl1);
+
+	if (err)
+		return err;
+
+	pllctl0_new = PLLCTL0_PLL_PRD_SET(pll_prd) |
+		PLLCTL0_PLL_FBD_SET(pll_fbd);
+
+    printk( KERN_ALERT "**** %s %i   pllctl0: 0x%04x   pllctl1: 0x%04x   pllctl0_new: 0x%04x\n",
+			__func__, __LINE__, pllctl0, pllctl1, pllctl0_new );
+
+	/*
+	 * Only rewrite when needed (new value or disabled), since rewriting
+	 * triggers another format change event.
+	 */
+
+	if (pllctl0 != pllctl0_new || (pllctl1 & PLLCTL1_PLL_EN_MASK) == 0) {
+		u16 pllctl1_mask = PLLCTL1_PLL_FRS_MASK | PLLCTL1_RESETB_MASK |
+				   PLLCTL1_PLL_EN_MASK;
+		u16 pllctl1_val = PLLCTL1_PLL_FRS_SET(pll_frs) |
+				  PLLCTL1_RESETB_MASK | PLLCTL1_PLL_EN_MASK;
+
+		err = my_regmap_write2(regmap, PLLCTL0, pllctl0_new);
+		if (!err)
+			err = my_regmap_update_bits2(regmap, PLLCTL1,
+						 pllctl1_mask, pllctl1_val);
+		udelay(1000);
+
+		if (!err)
+			err = my_regmap_update_bits2(regmap, PLLCTL1,
+						 PLLCTL1_CKEN_MASK,
+						 PLLCTL1_CKEN_MASK);
+	}
+
+	return err;
+}
+
+static int tc358746_set_csi_color_space(struct regmap *regmap,
+		u8 pdformat, u8 pdataf)
+{
+	int err;
+
+	err = my_regmap_update_bits2(regmap, DATAFMT,
+				 (DATAFMT_PDFMT_MASK | DATAFMT_UDT_EN_MASK),
+				 DATAFMT_PDFMT_SET(pdformat));
+
+	if (!err)
+		err = my_regmap_update_bits2(regmap, CONFCTL, CONFCTL_PDATAF_MASK,
+					 CONFCTL_PDATAF_SET(pdataf));
+
+	return err;
+}
+
+static int tc358746_set_buffers(struct regmap *regmap,
+		u32 fmt_width, u8 bpp, u16 vb_fifo)
+{
+	unsigned int byte_per_line = (fmt_width * bpp) / 8;
+	int err;
+
+	err = my_regmap_write2(regmap, FIFOCTL, vb_fifo);
+
+	if (!err)
+		err = my_regmap_write2(regmap, WORDCNT, byte_per_line);
+
+	return err;
+}
+
+static int tc358746_enable_csi_lanes(struct regmap *regmap,
+		int lane_num, int enable)
+{
+	u32 val = 0;
+	int err = 0;
+
+	if (lane_num < 1 || !enable) {
+		if (!err)
+			err = my_regmap_write2(regmap, CLW_CNTRL,
+					   CLW_CNTRL_CLW_LANEDISABLE_MASK);
+		if (!err)
+			err = my_regmap_write2(regmap, D0W_CNTRL,
+					   D0W_CNTRL_D0W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 2 || !enable) {
+		if (!err)
+			err = my_regmap_write2(regmap, D1W_CNTRL,
+					   D1W_CNTRL_D1W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 3 || !enable) {
+		if (!err)
+			err = my_regmap_write2(regmap, D2W_CNTRL,
+					   D2W_CNTRL_D2W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 4 || !enable) {
+		if (!err)
+			err = my_regmap_write2(regmap, D3W_CNTRL,
+					   D2W_CNTRL_D3W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num > 0 && enable) {
+		val |= HSTXVREGEN_CLM_HSTXVREGEN_MASK |
+			HSTXVREGEN_D0M_HSTXVREGEN_MASK;
+	}
+
+	if (lane_num > 1 && enable)
+		val |= HSTXVREGEN_D1M_HSTXVREGEN_MASK;
+
+	if (lane_num > 2 && enable)
+		val |= HSTXVREGEN_D2M_HSTXVREGEN_MASK;
+
+	if (lane_num > 3 && enable)
+		val |= HSTXVREGEN_D3M_HSTXVREGEN_MASK;
+
+	if (!err)
+		err = my_regmap_write2(regmap, HSTXVREGEN, val);
+
+	return err;
+}
+
+struct tc358746_csi_param {
+	bool is_continuous_clk;
+
+	/* CSI2-TX Parameters */
+	u32 lineinitcnt;
+	u32 lptxtimecnt;
+	u32 twakeupcnt;
+	u32 tclk_preparecnt;
+	u32 tclk_zerocnt;
+	u32 tclk_trailcnt;
+	u32 tclk_postcnt;
+	u32 ths_preparecnt;
+	u32 ths_zerocnt;
+	u32 ths_trailcnt;
+
+	u32 hstxvregcnt;
+};
+
+static void tc358746_csi_param_set_default(
+		struct tc358746_csi_param *param,
+		bool discontinuous_clk)
+{
+	param->is_continuous_clk = !discontinuous_clk;
+
+	param->lineinitcnt = 6500;
+	param->lptxtimecnt = 6;
+
+	param->tclk_preparecnt = 6;
+	param->tclk_zerocnt = 35;
+
+	/* default, skipped but value in excell = 0 */
+	param->tclk_trailcnt = 4;
+
+	param->ths_preparecnt = 6;
+	param->ths_zerocnt = 8;
+
+	param->twakeupcnt = 25000;
+
+	/* default, skipped but value in excell = 4 */
+	param->tclk_postcnt = 12;
+
+	param->ths_trailcnt = 5;
+
+	/* only presents in the excell, default: 32 */
+	param->hstxvregcnt = 5;
+}
+
+static int tc358746_set_csi(struct regmap *regmap,
+		struct tc358746_csi_param *param)
+{
+	u32 val;
+	int err;
+
+	val = TCLK_HEADERCNT_TCLK_ZEROCNT_SET(param->tclk_zerocnt) |
+	      TCLK_HEADERCNT_TCLK_PREPARECNT_SET(param->tclk_preparecnt);
+	err = my_regmap_write2(regmap, TCLK_HEADERCNT, val);
+
+	val = THS_HEADERCNT_THS_ZEROCNT_SET(param->ths_zerocnt) |
+	      THS_HEADERCNT_THS_PREPARECNT_SET(param->ths_preparecnt);
+	if (!err)
+		err = my_regmap_write2(regmap, THS_HEADERCNT, val);
+
+	if (!err)
+		err = my_regmap_write2(regmap, TWAKEUP, param->twakeupcnt);
+
+	if (!err)
+		err = my_regmap_write2(regmap, TCLK_POSTCNT, param->tclk_postcnt);
+
+	if (!err)
+		err = my_regmap_write2(regmap, THS_TRAILCNT, param->ths_trailcnt);
+
+	if (!err)
+		err = my_regmap_write2(regmap, LINEINITCNT, param->lineinitcnt);
+
+	if (!err)
+		err = my_regmap_write2(regmap, LPTXTIMECNT, param->lptxtimecnt);
+
+	if (!err)
+		err = my_regmap_write2(regmap, TCLK_TRAILCNT, param->tclk_trailcnt);
+
+	if (!err)
+		err = my_regmap_write2(regmap, HSTXVREGCNT, param->hstxvregcnt);
+
+	val = param->is_continuous_clk ? TXOPTIONCNTRL_CONTCLKMODE_MASK : 0;
+	if (!err)
+		err = my_regmap_write2(regmap, TXOPTIONCNTRL, val);
+
+	return err;
+}
+
+static int tc38764_debug_pattern_80(struct regmap *regmap)
+{
+	int i, err;
+
+	err = regmap_write(regmap, DBG_ACT_LINE_CNT, 0x8000);
+	if (!err)
+		/* err = regmap_write(regmap, DBG_LINE_WIDTH, 0x0821); */
+		err = regmap_write(regmap, DBG_LINE_WIDTH, 0x0fa1);
+	if (!err)
+		err = regmap_write(regmap, DBG_VERT_BLANK_LINE_CNT, 0);
+
+	/* White 80pixel */
+	for (i = 0; i < 120 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+	}
+
+	/* Yellow 80pixel, BGR: 00 FF FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+	}
+
+	/* Cyan 80pixel, BGR: FF FF 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+	}
+
+	/* Green 80pixel, BGR: 00 FF 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+	}
+
+	/* Magenda 80pixel, BGR: FF 00 FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+	}
+
+	/* Red 80pixel, BGR: 00 00 FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+	}
+
+	/* Blue 80pixel, BGR: FF 00 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+	}
+
+	/* Black 80pixel */
+	for (i = 0; i < 120 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+	}
+
+	return err;
+}
+
+static int tc358746_wr_csi_control(struct regmap *regmap, u32 val)
+{
+	u32 _val;
+
+	val &= CSI_CONFW_DATA_MASK;
+	_val = CSI_CONFW_MODE_SET_MASK | CSI_CONFW_ADDRESS_CSI_CONTROL_MASK |
+		val;
+
+	return my_regmap_write2(regmap, CSI_CONFW, _val);
+}
+
+static int tc358746_enable_csi_module(struct regmap *regmap, int lane_num)
+{
+	u32 val;
+	int err;
+
+	err = my_regmap_write2(regmap, STARTCNTRL, STARTCNTRL_START_MASK);
+
+	if (!err)
+		err = my_regmap_write2(regmap, CSI_START, CSI_START_STRT_MASK);
+
+	val = CSI_CONTROL_NOL_1_MASK;
+	if (lane_num == 2)
+		val = CSI_CONTROL_NOL_2_MASK;
+	else if (lane_num == 3)
+		val = CSI_CONTROL_NOL_3_MASK;
+	else if (lane_num == 4)
+		val = CSI_CONTROL_NOL_4_MASK;
+
+	val |= CSI_CONTROL_CSI_MODE_MASK | CSI_CONTROL_TXHSMD_MASK |
+		CSI_CONTROL_EOTDIS_MASK; /* add according to excell */
+
+	if (!err)
+		err = tc358746_wr_csi_control(regmap, val);
+
+	return err;
+}
+
+static int dione1280_set_mode(struct tegracam_device *tc_dev)
+{
+	struct dione1280 *priv = (struct dione1280 *)tegracam_get_privdata(tc_dev);
+	struct regmap *ctl_regmap = priv->ctl_regmap;
+	struct regmap *tx_regmap = priv->tx_regmap;
+	int err;
+
+	/* Parameters:
+	 *
+	 * 1. pll setup:
+	 * - pll_prd: Pre Divider value // calc
+	 * - pll_fbd: Multiply value of Unit Clock // calc
+	 * - pll_frs: CSI speed/lane // calc
+	 *
+	 * 2. setup format: RGB888
+	 * - pdformat: 0x3 // dt
+	 * - pdataformat: 0x0 // dt
+	 *
+	 * 3. setup buffers:
+	 * - fmt_width = 640 // dt
+	 * - bpp = 24 (bits per pixel) // dt
+	 * - vb_fifo = 247 (fifo size) // calc
+	 *
+	 * 4. setup csi lanes
+	 * - lane_num = 2 // dt
+	 * - struct tc358746_csi_param // calc
+	 * - discontinuous_clk = true // dt
+	 *
+	 * 5. test_mode
+	 */
+	u16 pll_prd = 3, pll_fbd = 125, pll_frs = 0;
+	u8 pdformat = 0x3, pdataf = 0x0;
+	u32 fmt_width = 1280; u8 bpp = 24; u16 vb_fifo = 2;
+	int lane_num = 2;
+	struct tc358746_csi_param csi_setting;
+	bool discontinuous_clk = false;
+
+	tc358746_csi_param_set_default(&csi_setting, discontinuous_clk);
+
+	my_regmap_write2(ctl_regmap, DBG_ACT_LINE_CNT, 0);
+
+	err = tc358746_sreset(ctl_regmap);
+	if (err) {
+		dev_err(tc_dev->dev, "Failed to reset chip\n");
+		return err;
+	}
+
+	err = tc358746_set_pll(ctl_regmap, pll_prd, pll_fbd, pll_frs);
+	if (err) {
+		dev_err(tc_dev->dev, "Failed to setup PLL\n");
+		return err;
+	}
+
+	err = tc358746_set_csi_color_space(ctl_regmap, pdformat, pdataf);
+
+	if (!err)
+		err = tc358746_set_buffers(ctl_regmap, fmt_width, bpp, vb_fifo);
+
+	if (!err)
+		err = tc358746_enable_csi_lanes(tx_regmap, lane_num, true);
+
+	if (!err)
+		err = tc358746_set_csi(tx_regmap, &csi_setting);
+
+	if (!err && test_mode)
+		err = tc38764_debug_pattern_80(ctl_regmap);
+
+	if (!err)
+		err = tc358746_enable_csi_module(tx_regmap, lane_num);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static int dione1280_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct dione1280 *priv = (struct dione1280 *)tegracam_get_privdata(tc_dev);
+	struct regmap *ctl_regmap = priv->ctl_regmap;
+	int err;
+
+	err = my_regmap_write2(ctl_regmap, PP_MISC, 0);
+	if (test_mode) {
+		if (!err)
+			/* err = my_regmap_write2(ctl_regmap, DBG_ACT_LINE_CNT, 0xc1df); */
+			err = my_regmap_write2(ctl_regmap, DBG_ACT_LINE_CNT, 0xc3fe);
+	} else {
+		if (!err)
+			err = my_regmap_update_bits2(ctl_regmap, CONFCTL,
+						 CONFCTL_PPEN_MASK,
+						 CONFCTL_PPEN_MASK);
+	}
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static int dione1280_stop_streaming(struct tegracam_device *tc_dev)
+{
+	struct dione1280 *priv = (struct dione1280 *)tegracam_get_privdata(tc_dev);
+	struct regmap *ctl_regmap = priv->ctl_regmap;
+	struct regmap *tx_regmap = priv->tx_regmap;
+	int err;
+
+	err = my_regmap_update_bits2(ctl_regmap, PP_MISC, PP_MISC_FRMSTOP_MASK,
+				 PP_MISC_FRMSTOP_MASK);
+	if (!err)
+		err = my_regmap_update_bits2(ctl_regmap, CONFCTL,
+					 CONFCTL_PPEN_MASK, 0);
+
+	if (!err)
+		err = my_regmap_update_bits2(ctl_regmap, PP_MISC,
+					 PP_MISC_RSTPTR_MASK,
+					 PP_MISC_RSTPTR_MASK);
+
+	if (!err)
+		err = my_regmap_write2(tx_regmap, CSIRESET,
+				   (CSIRESET_RESET_CNF_MASK |
+				    CSIRESET_RESET_MODULE_MASK));
+	if (!err)
+		err = my_regmap_write2(ctl_regmap, DBG_ACT_LINE_CNT, 0);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static struct camera_common_sensor_ops dione1280_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(dione1280_frmfmt),
+	.frmfmt_table = dione1280_frmfmt,
+	.power_on = dione1280_power_on,
+	.power_off = dione1280_power_off,
+	.write_reg = dione1280_write_reg,
+	.read_reg = dione1280_read_reg,
+	.parse_dt = dione1280_parse_dt,
+	.power_get = dione1280_power_get,
+	.power_put = dione1280_power_put,
+	.set_mode = dione1280_set_mode,
+	.start_streaming = dione1280_start_streaming,
+	.stop_streaming = dione1280_stop_streaming,
+};
+
+static int generic_i2c_read(struct i2c_client *client, void *buf, size_t len)
+{
+	struct i2c_msg msgs[1];
+	int ret;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = I2C_M_RD;
+	msgs[0].len = len;
+	msgs[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	return ret;
+} /* generic_i2c_read */
+
+
+static int generic_i2c_write(struct i2c_client *client, void *buf, size_t len)
+{
+	struct i2c_msg msgs[1];
+	int ret;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = len;
+	msgs[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	return ret;
+} /* generic_i2c_write */
+
+
+#if 0
+
+static void hex_dump( uint8_t *pc_src, uint32_t i_len, uint32_t i_width, uint32_t i_offs )
+{
+  uint32_t  i;
+  char line1[128], line2[16];
+
+  while( i_len > 0 )
+  {
+    sprintf( line1, "%04x:", i_offs );
+    i_offs += i_width;
+    if( i_width > i_len )
+      i_width = i_len;
+    for( i = 0 ; i < i_width ; i++ )
+    {
+      sprintf( line2, " %02x", *pc_src++ );
+	  strcat( line1, line2 );
+      i_len--;
+    }
+	printk( KERN_ALERT "%s\n", line1 );
+  }
+} /* hex_dump */
+
+#endif
+
+
+static int dione1280_i2c_read( struct i2c_client *client, u32 addr, u8 *buf, u16 len )
+{
+	u8 tmp_buf[72];
+	int ret, tmo, retry;
+
+	ret = 0;
+	if (len > sizeof(tmp_buf) - 2)
+		ret = -1;
+
+	if (!ret) {
+		*( (u32 *)tmp_buf ) = addr;
+		*( (u16 *)tmp_buf + 2 ) = len;
+		retry = 4;
+		tmo = DIONE1280_I2C_TMO_MS ;
+		ret = -1;
+		while (retry-- > 0) {
+			if (generic_i2c_write(client, tmp_buf, 6) == 1) {
+				ret = 0;
+				break;
+			}
+			msleep(tmo);
+			tmo <<= 2;
+		}
+	}
+
+	if (!ret) {
+		retry = 4;
+		tmo = DIONE1280_I2C_TMO_MS ;
+		ret = -1;
+		msleep(2);
+		while (retry-- > 0) {
+			if (generic_i2c_read(client, tmp_buf, len+2) == 1) {
+				ret = 0;
+				break;
+			}
+			msleep(tmo);
+			tmo <<= 2;
+		}
+	}
+
+	if (!ret) {
+		if ((tmp_buf[0] != 0) || (tmp_buf[1] != 0))
+			ret = -1;
+		else
+			memcpy(buf, tmp_buf+2, len);
+	}
+
+	return ret;
+}
+
+
+static int dione1280_board_setup(struct dione1280 *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	struct regmap *ctl_regmap = priv->ctl_regmap;
+	u8 buf[64];
+	int ret, cnt;
+	u32 reg_val;
+	int err = 0;
+
+	if (pdata->mclk_name) {
+		err = camera_common_mclk_enable(s_data);
+		if (err) {
+			dev_err(dev, "error turning on mclk (%d)\n", err);
+			goto done;
+		}
+	}
+
+	err = dione1280_power_on(s_data);
+	if (err) {
+		dev_err(dev, "error during power on sensor (%d)\n", err);
+		goto err_power_on;
+	}
+
+    printk( KERN_ALERT "**** %s %i   s_data: 0x%08lx   pw: 0x%08lx\n", __func__, __LINE__, (long )s_data, (long )s_data->power );
+	
+	msleep( 500 );
+
+	/* Probe sensor model id registers */
+	err = regmap_read(ctl_regmap, CHIPID, &reg_val);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+
+	if ((reg_val & CHIPID_CHIPID_MASK) != 0x4400) {
+		dev_err(dev, "%s: invalid sensor model id: %x\n",
+			__func__, reg_val);
+		err = -ENODEV;
+		goto err_reg_probe;
+	}
+
+	ret = dione1280_i2c_read(priv->sens_client, DIONE1280_REG_WIDTH_MAX, (u8 *)&reg_val, 4);
+	if (ret || (reg_val != 1280)) {
+		printk( KERN_ALERT "**** %s %i   ret: %i   WidthMax: %i\n", __func__, __LINE__, ret, (int )reg_val);
+		err = -ENODEV;
+		goto err_reg_probe;
+	}
+
+	ret = dione1280_i2c_read(priv->sens_client, DIONE1280_REG_FIRMWARE_VERSION, buf, 64);
+	if (!ret) {
+		cnt = 63;
+		while ((cnt > 0) && (buf[cnt] == 0xff))
+			buf[cnt--] = 0;
+		dev_info(dev, "FirmwareVersion: %s\n", buf);
+	}
+	else {
+		printk( KERN_ALERT "**** %s %i   ret: %i\n", __func__, __LINE__, ret);
+		err = -ENODEV;
+		goto err_reg_probe;
+	}
+
+err_reg_probe:
+	dione1280_power_off(s_data);
+
+err_power_on:
+	if (pdata->mclk_name)
+		camera_common_mclk_disable(s_data);
+
+done:
+	return err;
+}
+
+static int dione1280_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops dione1280_subdev_internal_ops = {
+	.open = dione1280_open,
+};
+
+static int dione1280_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tegracam_device *tc_dev;
+	struct dione1280 *priv;
+	struct i2c_client *tc35_client;
+	int err;
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	priv = devm_kzalloc(dev, sizeof(struct dione1280), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return -ENOMEM;
+
+	tc35_client = i2c_new_dummy(client->adapter, TC358746_I2C_ADDR);
+    printk( KERN_ALERT "**** %s %i   tc35_client: 0x%08lx\n", __func__, __LINE__, (long )tc35_client );
+	
+	if (!tc35_client)
+		return -ENODEV;
+
+	priv->sens_client = tc_dev->client = client;
+	priv->tc35_client = tc35_client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "dione1280", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &dummy_regmap_config;
+	tc_dev->sensor_ops = &dione1280_common_ops;
+	tc_dev->v4l2sd_internal_ops = &dione1280_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &dione1280_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		dev_err(dev, "tegra camera driver registration failed\n");
+		goto err_register;
+	}
+
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+
+	priv->tx_regmap = devm_regmap_init_i2c(tc35_client,
+										   &tx_regmap_config);
+	if (IS_ERR(priv->tx_regmap)) {
+		dev_err(dev, "tx_regmap init failed: %ld\n",
+			PTR_ERR(priv->tx_regmap));
+		err = -ENODEV;
+		goto err_regmap;
+	}
+
+	priv->ctl_regmap = devm_regmap_init_i2c(tc35_client,
+											&ctl_regmap_config);
+	if (IS_ERR(priv->ctl_regmap)) {
+		dev_err(dev, "ctl_regmap init failed: %ld\n",
+			PTR_ERR(priv->ctl_regmap));
+		err = -ENODEV;
+		goto err_regmap;
+	}
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+
+	err = dione1280_board_setup(priv);
+	if (err) {
+		dev_err(dev, "board setup failed\n");
+		goto err_board_setup;
+	}
+
+    printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
+		goto err_board_setup;
+	}
+
+	dev_info(dev, "detected dione1280 sensor\n");
+	goto err_none;
+
+err_board_setup:
+
+err_regmap:
+	/* about to call dione1280_power_put()->
+	                 i2c_unregister_device()->
+					 regmap_exit() */
+	tegracam_device_unregister(tc_dev);
+
+err_register:
+	if (priv->tc35_client != NULL) {
+		i2c_unregister_device(priv->tc35_client);
+		priv->tc35_client = NULL;
+	}
+
+err_none:
+	return err;
+}
+
+static int dione1280_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct dione1280 *priv = (struct dione1280 *)s_data->priv;
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id dione1280_id[] = {
+	{ "dione1280", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, dione1280_id);
+
+static struct i2c_driver dione1280_i2c_driver = {
+	.driver = {
+		.name = "dione1280",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(dione1280_of_match),
+	},
+	.probe = dione1280_probe,
+	.remove = dione1280_remove,
+	.id_table = dione1280_id,
+};
+module_i2c_driver(dione1280_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Xenics Dione1280");
+MODULE_AUTHOR("Xenics Infrared Solutions / Botond Kardos");
+MODULE_LICENSE("GPL v2");
diff --git a/nvidia/drivers/media/i2c/tc358746_regs.h b/nvidia/drivers/media/i2c/tc358746_regs.h
index 9232d00d0e92..3d730eb944e3 100644
--- a/nvidia/drivers/media/i2c/tc358746_regs.h
+++ b/nvidia/drivers/media/i2c/tc358746_regs.h
@@ -16,6 +16,8 @@
 #ifndef __TC358746_REGS_H
 #define __TC358746_REGS_H
 
+#define TC358746_I2C_ADDR		0x0e
+
 #define CHIPID			0x0000
 #define CHIPID_CHIPID_MASK		GENMASK(15, 8)
 #define CHIPID_REVID_MASK		GENMASK(7, 0)
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione1280.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione1280.dtsi
new file mode 100644
index 000000000000..92202b96bfbe
--- /dev/null
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione1280.dtsi
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) 2021, Xenics Infrared Solutions.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <dt-bindings/media/camera.h>
+#include <dt-bindings/platform/t210/t210.h>
+
+/ {
+	host1x {
+		vi_base: vi {
+			num-channels = <1>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				vi_port0: port@0 {
+					reg = <0>;
+					rbpcv2_dione1280_vi_in0: endpoint {
+						port-index = <0>;
+						bus-width = <2>;
+						remote-endpoint = <&rbpcv2_dione1280_csi_out0>;
+					};
+				};
+			};
+		};
+
+		csi_base: nvcsi {
+			num-channels = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			csi_chan0: channel@0 {
+				reg = <0>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan0_port0: port@0 {
+						reg = <0>;
+						rbpcv2_dione1280_csi_in0: endpoint@0 {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_dione1280_out0>;
+						};
+					};
+					csi_chan0_port1: port@1 {
+						reg = <1>;
+						rbpcv2_dione1280_csi_out0: endpoint@1 {
+							remote-endpoint = <&rbpcv2_dione1280_vi_in0>;
+						};
+					};
+				};
+			};
+		};
+
+		i2c@546c0000 {
+			dione1280_single_cam0: rbpcv2_dione1280_a@5b {
+				compatible = "xenics,dione1280";
+				/* I2C device address */
+				reg = <0x5b>;
+
+				/* V4L2 device node location */
+				devnode = "video0";
+
+				/* Physical dimensions of sensor */
+				physical_w = "7.680";
+				physical_h = "5.760";
+
+				sensor_model = "dione1280";
+
+				use_sensor_mode_id = "true";
+
+				/**
+				* ==== Modes ====
+				* A modeX node is required to support v4l2 driver
+				* implementation with NVIDIA camera software stack
+				*
+				* == Signal properties ==
+				*
+				* phy_mode = "";
+				* PHY mode used by the MIPI lanes for this device
+				*
+				* tegra_sinterface = "";
+				* CSI Serial interface connected to tegra
+				* Incase of virtual HW devices, use virtual
+				* For SW emulated devices, use host
+				*
+				* pix_clk_hz = "";
+				* Sensor pixel clock used for calculations like exposure and framerate
+				*
+				* readout_orientation = "0";
+				* Based on camera module orientation.
+				* Only change readout_orientation if you specifically
+				* Program a different readout order for this mode
+				*
+				* == Image format Properties ==
+				*
+				* active_w = "";
+				* Pixel active region width
+				*
+				* active_h = "";
+				* Pixel active region height
+				*
+				* pixel_t = "";
+				* The sensor readout pixel pattern
+				*
+				* line_length = "";
+				* Pixel line length (width) for sensor mode.
+				*
+				* == Source Control Settings ==
+				*
+				* Gain factor used to convert fixed point integer to float
+				* Gain range [min_gain/gain_factor, max_gain/gain_factor]
+				* Gain step [step_gain/gain_factor is the smallest step that can be configured]
+				* Default gain [Default gain to be initialized for the control.
+				*     use min_gain_val as default for optimal results]
+				* Framerate factor used to convert fixed point integer to float
+				* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
+				* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
+				* Default Framerate [Default framerate to be initialized for the control.
+				*     use max_framerate to get required performance]
+				* Exposure factor used to convert fixed point integer to float
+				* For convenience use 1 sec = 1000000us as conversion factor
+				* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
+				* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
+				* Default Exposure Time [Default exposure to be initialized for the control.
+				*     Set default exposure based on the default_framerate for optimal exposure settings]
+				*
+				* gain_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_gain_val = ""; (ceil to integer)
+				* max_gain_val = ""; (ceil to integer)
+				* step_gain_val = ""; (ceil to integer)
+				* default_gain = ""; (ceil to integer)
+				* Gain limits for mode
+				*
+				* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_exp_time = ""; (ceil to integer)
+				* max_exp_time = ""; (ceil to integer)
+				* step_exp_time = ""; (ceil to integer)
+				* default_exp_time = ""; (ceil to integer)
+				* Exposure Time limits for mode (sec)
+				*
+				* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_framerate = ""; (ceil to integer)
+				* max_framerate = ""; (ceil to integer)
+				* step_framerate = ""; (ceil to integer)
+				* default_framerate = ""; (ceil to integer)
+				* Framerate limits for mode (fps)
+				*
+				* embedded_metadata_height = "";
+				* Sensor embedded metadata height in units of rows.
+				* If sensor does not support embedded metadata value should be 0.
+				*/
+				mode0 { /* DIONE1280_MODE_1280x1024_60FPS */
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_a";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes";
+					dpcm_enable = "false";
+					cil_settletime = "0";
+
+					active_w = "1280";
+					active_h = "1024";
+					pixel_t = "rgb_rgb88824";
+					readout_orientation = "0";
+					line_length = "1334";
+					/* inherent_gain = "1"; */
+					/* mclk_multiplier = "9.33"; */
+					pix_clk_hz = "83000000";
+
+					/* unused */
+					gain_factor = "16";
+					exposure_factor = "1000000";
+					min_gain_val = "16"; /* 1.00x */
+					max_gain_val = "170"; /* 10.66x */
+					step_gain_val = "1";
+					default_gain = "16"; /* 1.00x */
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+
+					/* framerate */
+					framerate_factor = "1000000";
+					min_framerate = "40000000"; /* 40 fps */
+					max_framerate = "62000000"; /* 62 fps */
+					step_framerate = "1";
+					default_framerate = "60756000"; /* 60.756 fps */
+
+					/* unused */
+					min_exp_time = "13"; /* us */
+					max_exp_time = "683709"; /* us */
+					step_exp_time = "1";
+					default_exp_time = "2495"; /* us */
+
+					embedded_metadata_height = "0";
+				};
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						rbpcv2_dione1280_out0: endpoint {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_dione1280_csi_in0>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	/* CN 3423-xx SN xxxx 55mm F/1 */
+	lens_dione1280@RBPCV2 {
+		min_focus_distance = "2000.0"; /* F.R 2m ~ ... */
+		hyper_focal = "0.0";
+		focal_length = "55.0"; /* E.F.L 55mm */
+		f_number = "1.0"; /* F.NO 1.0 */
+		aperture = "0.0";
+	};
+};
+
+/ {
+	tcp: tegra-camera-platform {
+		compatible = "nvidia, tegra-camera-platform";
+
+		/**
+		* Physical settings to calculate max ISO BW
+		*
+		* num_csi_lanes = <>;
+		* Total number of CSI lanes when all cameras are active
+		*
+		* max_lane_speed = <>;
+		* Max lane speed in Kbit/s
+		*
+		* min_bits_per_pixel = <>;
+		* Min bits per pixel
+		*
+		* vi_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the VI ISO case
+		*
+		* vi_bw_margin_pct = <>;
+		* Vi bandwidth margin in percentage
+		*
+		* max_pixel_rate = <>;
+		* Max pixel rate in Kpixel/s for the ISP ISO case
+		*
+		* isp_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the ISP ISO case
+		*
+		* isp_bw_margin_pct = <>;
+		* Isp bandwidth margin in percentage
+		*/
+		num_csi_lanes = <2>;
+		max_lane_speed = <1500000>;
+		min_bits_per_pixel = <10>;
+		vi_peak_byte_per_pixel = <2>;
+		vi_bw_margin_pct = <25>;
+		max_pixel_rate = <240000>;
+		isp_peak_byte_per_pixel = <5>;
+		isp_bw_margin_pct = <25>;
+
+		/**
+		 * The general guideline for naming badge_info contains 3 parts, and is as follows,
+		 * The first part is the camera_board_id for the module; if the module is in a FFD
+		 * platform, then use the platform name for this part.
+		 * The second part contains the position of the module, ex. "rear" or "front".
+		 * The third part contains the last 6 characters of a part number which is found
+		 * in the module's specsheet from the vendor.
+		 */
+		modules {
+			cam_module0: module0 {
+				badge = "porg_front_RBPCV2";
+				position = "front";
+				orientation = "1";
+				cam_module0_drivernode0: drivernode0 {
+					pcl_id = "v4l2_sensor";
+					devname = "dione1280 6-005b";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione1280_a@5b";
+				};
+				cam_module0_drivernode1: drivernode1 {
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_dione1280@RBPCV2/";
+				};
+			};
+		};
+	};
+};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione640.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione640.dtsi
index 56ad44c52685..af392edbf64d 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione640.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione640.dtsi
@@ -64,10 +64,10 @@
 		};
 
 		i2c@546c0000 {
-			dione640_single_cam0: rbpcv2_dione640_a@0e {
+			dione640_single_cam0: rbpcv2_dione640_a@5a {
 				compatible = "xenics,dione64";
 				/* I2C device address */
-				reg = <0x0e>;
+				reg = <0x5a>;
 
 				/* V4L2 device node location */
 				devnode = "video0";
@@ -170,14 +170,14 @@
 					dpcm_enable = "false";
 					cil_settletime = "0";
 
-					active_w = "640";
-					active_h = "480";
+					active_w = "1280";
+					active_h = "1024";
 					pixel_t = "rgb_rgb88824";
 					readout_orientation = "0";
-					line_length = "694";
+					line_length = "1334";
 					/* inherent_gain = "1"; */
 					/* mclk_multiplier = "9.33"; */
-					pix_clk_hz = "20000000";
+					pix_clk_hz = "83000000";
 
 					/* unused */
 					gain_factor = "16";
@@ -194,7 +194,7 @@
 					min_framerate = "40000000"; /* 40 fps */
 					max_framerate = "62000000"; /* 62 fps */
 					step_framerate = "1";
-					default_framerate = "60020000"; /* 60.020 fps */
+					default_framerate = "60756000"; /* 60.756 fps */
 
 					/* unused */
 					min_exp_time = "13"; /* us */
@@ -287,8 +287,8 @@
 				orientation = "1";
 				cam_module0_drivernode0: drivernode0 {
 					pcl_id = "v4l2_sensor";
-					devname = "dione64 6-000e";
-					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione640_a@0e";
+					devname = "dione64 6-005a";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione640_a@5a";
 				};
 				cam_module0_drivernode1: drivernode1 {
 					pcl_id = "v4l2_lens";
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione1280.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione1280.dtsi
new file mode 100644
index 000000000000..2f0ecc100abe
--- /dev/null
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione1280.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2018-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "tegra210-camera-rbpcv2-dione1280.dtsi"
+
+#define CAM1_PWDN		TEGRA_GPIO(S, 7)
+
+/ {
+    host1x {
+		i2c@546c0000 {
+			clock-frequency = <1000000>;
+
+			rbpcv2_dione1280_a@5b {
+				status = "disabled";
+				reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+
+    gpio@6000d000 {
+		camera-control-output-low {
+			gpio-hog;
+			output-low;
+			gpios = < CAM1_PWDN 0 >;
+			label = "cam1-pwdn";
+		};
+	};
+};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi
index 296e1d2c8eae..5bc24430aa49 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi
@@ -22,7 +22,9 @@
 / {
     host1x {
 		i2c@546c0000 {
-			rbpcv2_dione640_a@0e {
+			clock-frequency = <1000000>;
+
+			rbpcv2_dione640_a@5a {
 				status = "disabled";
 				reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
 			};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
index ac3997cde550..24eb1042b1da 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
@@ -15,7 +15,8 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #include "tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
-#include "tegra210-porg-camera-rbpcv2-dione640.dtsi"
+/* #include "tegra210-porg-camera-rbpcv2-dione640.dtsi" */
+#include "tegra210-porg-camera-rbpcv2-dione1280.dtsi"
 
 / {
 	tegra-camera-platform {
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
index dd19f0c5de26..7876dbe218fb 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
@@ -170,6 +170,7 @@
                         };
                 };
 
+#if 0
 		fragement@9 {
 			ids = "<3448-0000-300", "<3448-0002-300" , ">=3448-0003-000";
 			override@0 {
@@ -206,8 +207,8 @@
 				_overlay_ {
 					status = "okay";
 					pcl_id = "v4l2_sensor";
-					devname = "dione64 6-000e";
-					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione640_a@0e";
+					devname = "dione64 6-005a";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione640_a@5a";
 				};
 			};
 			override@5 {
@@ -302,6 +303,7 @@
 				};
 			};
 		};
+#endif
 
 		fragement@10 {
 			ids = ">=3448-0000-300", ">=3448-0002-300";
@@ -516,6 +518,141 @@
 			};
 		};
 
+		fragement@11 {
+			ids = "<3448-0000-300", "<3448-0002-300" , ">=3448-0003-000";
+
+			/* Dione1280 sensor module */
+			override@0 {
+				target = <&max77620_ldo6>;
+				_overlay_ {
+                                        status = "disabled";
+				};
+			};
+			override@1 {
+				target = <&sdhci2>;
+				_overlay_ {
+					keep-power-in-suspend;
+					non-removable;
+				};
+			};
+			/* dione1280 single sensor module */
+			override@2 {
+				target = <&dione1280_single_cam0>;
+				_overlay_ {
+					status = "okay";
+				};
+			};
+			override@3 {
+				target = <&cam_module0>;
+				_overlay_ {
+					status = "okay";
+					badge = "porg_front_RBPCV2";
+					position = "front";
+					orientation = "1";
+				};
+			};
+			override@4 {
+				target = <&cam_module0_drivernode0>;
+				_overlay_ {
+					status = "okay";
+					pcl_id = "v4l2_sensor";
+					devname = "dione1280 6-005b";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione1280_a@5b";
+				};
+			};
+			override@5 {
+				target = <&cam_module0_drivernode1>;
+				_overlay_ {
+					status = "okay";
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_dione1280@RBPCV2/";
+				};
+			};
+			/* Enable VI ports */
+			override@6 {
+				target = <&vi_base>;
+				_overlay_ {
+					num-channels=<1>;
+				};
+			};
+			override@7 {
+				target = <&vi_port0>;
+				_overlay_ {
+					status = "okay";
+				};
+			};
+			override@8 {
+				target = <&rbpcv2_dione1280_vi_in0>;
+				_overlay_ {
+					status = "okay";
+					port-index = <0>;
+					bus-width = <2>;
+					remote-endpoint = <&rbpcv2_dione1280_csi_out0>;
+				};
+			};
+			/* Enable CSI ports */
+			override@9 {
+				target = <&csi_base>;
+				_overlay_ {
+					num-channels=<1>;
+				};
+			};
+			override@10 {
+				target = <&csi_chan0>;
+				_overlay_ {
+					status = "okay";
+				};
+			};
+			override@11 {
+				target = <&csi_chan0_port0>;
+				_overlay_ {
+					status = "okay";
+				};
+			};
+			override@12 {
+				target = <&rbpcv2_dione1280_csi_in0>;
+				_overlay_ {
+					status = "okay";
+					port-index = <0>;
+					bus-width = <2>;
+					remote-endpoint = <&rbpcv2_dione1280_out0>;
+				};
+			};
+			override@13 {
+				target = <&csi_chan0_port1>;
+				_overlay_ {
+					status = "okay";
+				};
+			};
+			override@14 {
+				target = <&rbpcv2_dione1280_csi_out0>;
+				_overlay_ {
+					status = "okay";
+					remote-endpoint = <&rbpcv2_dione1280_vi_in0>;
+				};
+			};
+			/* tegra-camera-platform settings */
+			override@15 {
+				target = <&tcp>;
+				_overlay_ {
+					num_csi_lanes = <2>;
+					max_lane_speed = <1500000>;
+					min_bits_per_pixel = <10>;
+					vi_peak_byte_per_pixel = <2>;
+					vi_bw_margin_pct = <25>;
+					max_pixel_rate = <240000>;
+					isp_peak_byte_per_pixel = <5>;
+					isp_bw_margin_pct = <25>;
+				};
+			};
+			override@16 {
+				target = <&cam_module1>;
+				_overlay_ {
+					status = "disabled";
+				};
+			};
+		};
+
 		fragment@12 {
 			ids = ">=3448-0003-400";
 			override@0 {
diff --git a/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi b/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
index e7dc55b5bbfb..9d23b08dd2aa 100644
--- a/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
@@ -28,7 +28,8 @@
 #include "porg-platforms/tegra210-pinmux-drive-sdmmc-common.dtsi"
 #include "porg-platforms/tegra210-porg-pwm-fan.dtsi"
 #include "porg-platforms/tegra210-porg-camera.dtsi"
-#include "porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi"
+/* #include "porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi" */
+#include "porg-platforms/tegra210-porg-camera-rbpcv2-dione1280.dtsi"
 #include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
 #include <t210-common-platforms/tegra210-ers-hdmi-e2190-1100-a00.dtsi>
 #include <t210-common-platforms/tegra210-dp.dtsi>
-- 
2.25.1

