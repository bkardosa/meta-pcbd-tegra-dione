From 2f68433957bc8d5a442ea62076981fb2eab90809 Mon Sep 17 00:00:00 2001
From: Botond Kardos <bkardos70@gmail.com>
Date: Fri, 7 Jan 2022 16:23:20 +0100
Subject: [PATCH] initial version of common dione_ir driver added

dione_ir is a clone of the original dione640 driver in 6f7461a
---
 nvidia/drivers/media/i2c/Kconfig              |    9 +
 nvidia/drivers/media/i2c/Makefile             |    1 +
 nvidia/drivers/media/i2c/dione_ir.c           | 1099 +++++++++++++++++
 .../tegra210-camera-rbpcv2-dione-ir.dtsi      |  300 +++++
 .../tegra210-porg-camera-rbpcv2-dione-ir.dtsi |   42 +
 .../tegra210-porg-plugin-manager.dtsi         |   51 +
 .../tegra210-porg-p3448-common.dtsi           |    1 +
 7 files changed, 1503 insertions(+)
 create mode 100644 nvidia/drivers/media/i2c/dione_ir.c
 create mode 100644 nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione-ir.dtsi
 create mode 100644 nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi

diff --git a/nvidia/drivers/media/i2c/Kconfig b/nvidia/drivers/media/i2c/Kconfig
index 8668b551a96e..9bf65357ca40 100644
--- a/nvidia/drivers/media/i2c/Kconfig
+++ b/nvidia/drivers/media/i2c/Kconfig
@@ -21,6 +21,15 @@ config VIDEO_DIONE1280
 	  To compile this driver as a module, choose M here: the module
 	  will be called dione1280.
 
+config VIDEO_DIONE_IR
+	tristate "DIONE IR camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This driver supports DIONE640 and DIONE1280 infra camera sensors from Xenics
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called dione_ir.
+
 config VIDEO_IMX185
 	tristate "IMX185 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/nvidia/drivers/media/i2c/Makefile b/nvidia/drivers/media/i2c/Makefile
index 6155907af7ce..43fc3fde9456 100644
--- a/nvidia/drivers/media/i2c/Makefile
+++ b/nvidia/drivers/media/i2c/Makefile
@@ -23,3 +23,4 @@ obj-$(CONFIG_I2C_IOEXPANDER_DESER_MAX9296) += max9296.o
 obj-$(CONFIG_VIDEO_IMX390) += imx390.o
 obj-$(CONFIG_VIDEO_DIONE640) += dione640.o
 obj-$(CONFIG_VIDEO_DIONE1280) += dione1280.o
+obj-$(CONFIG_VIDEO_DIONE_IR) += dione_ir.o
diff --git a/nvidia/drivers/media/i2c/dione_ir.c b/nvidia/drivers/media/i2c/dione_ir.c
new file mode 100644
index 000000000000..7095b08cc6b8
--- /dev/null
+++ b/nvidia/drivers/media/i2c/dione_ir.c
@@ -0,0 +1,1099 @@
+/*
+ * dione_ir.c - Dione IR sensor driver
+ *
+ * Copyright (c) 2015-2020, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegracam_core.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "tc358746_regs.h"
+
+static int test_mode = 0;
+module_param(test_mode, int, 0644);
+
+enum {
+	DIONEIR_MODE_640x480_60FPS,
+};
+
+static const int dioneir_60fps[] = {
+	60,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in
+ * device tree!
+ */
+static const struct camera_common_frmfmt dioneir_frmfmt[] = {
+	{{640, 480},	dioneir_60fps, 1, 0, DIONEIR_MODE_640x480_60FPS},
+	/* Add modes with no device tree support after below */
+};
+
+static const struct regmap_range ctl_regmap_rw_ranges[] = {
+	regmap_reg_range(0x0000, 0x00ff),
+};
+
+static const struct regmap_access_table ctl_regmap_access = {
+	.yes_ranges = ctl_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(ctl_regmap_rw_ranges),
+};
+
+static const struct regmap_config ctl_regmap_config = {
+	.reg_bits = 16,
+	.reg_stride = 2,
+	.val_bits = 16,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0x00ff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.rd_table = &ctl_regmap_access,
+	.wr_table = &ctl_regmap_access,
+	.name = "tc358746-ctl",
+};
+
+static const struct regmap_range tx_regmap_rw_ranges[] = {
+	regmap_reg_range(0x0100, 0x05ff),
+};
+
+static const struct regmap_access_table tx_regmap_access = {
+	.yes_ranges = tx_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(tx_regmap_rw_ranges),
+};
+
+static const struct regmap_config tx_regmap_config = {
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0x05ff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG_LITTLE,
+	.rd_table = &tx_regmap_access,
+	.wr_table = &tx_regmap_access,
+	.name = "tc358746-tx",
+};
+
+static const struct of_device_id dioneir_of_match[] = {
+	{ .compatible = "xenics,dione_ir", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, dioneir_of_match);
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+};
+
+struct dione_struct {
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	struct regmap			*tx_regmap;
+	struct camera_common_data	*s_data;
+	struct tegracam_device		*tc_dev;
+};
+
+static inline int dioneir_read_reg(struct camera_common_data *s_data,
+	u16 addr, u8 *val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xff;
+
+	return err;
+}
+
+static inline int dioneir_write_reg(struct camera_common_data *s_data,
+	u16 addr, u8 val)
+{
+	int err = 0;
+
+	err = regmap_write(s_data->regmap, addr, val);
+	if (err)
+		dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int dioneir_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%d\n", __func__, val);
+	return 0;
+}
+
+static int dioneir_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static int dioneir_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static int dioneir_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static struct tegracam_ctrl_ops dioneir_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.set_gain = dioneir_set_gain,
+	.set_exposure = dioneir_set_exposure,
+	.set_frame_rate = dioneir_set_frame_rate,
+	.set_group_hold = dioneir_set_group_hold,
+};
+
+static int dioneir_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 0);
+		else
+			gpio_set_value(pw->reset_gpio, 0);
+	}
+
+	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
+		goto skip_power_seqn;
+
+	usleep_range(10, 20);
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		if (err)
+			goto dioneir_avdd_fail;
+	}
+
+	if (pw->iovdd) {
+		err = regulator_enable(pw->iovdd);
+		if (err)
+			goto dioneir_iovdd_fail;
+	}
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		if (err)
+			goto dioneir_dvdd_fail;
+	}
+
+	usleep_range(10, 20);
+
+skip_power_seqn:
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 1);
+		else
+			gpio_set_value(pw->reset_gpio, 1);
+	}
+
+	usleep_range(23000, 23100);
+
+	pw->state = SWITCH_ON;
+
+	return 0;
+
+dioneir_dvdd_fail:
+	regulator_disable(pw->iovdd);
+
+dioneir_iovdd_fail:
+	regulator_disable(pw->avdd);
+
+dioneir_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+
+	return -ENODEV;
+}
+
+static int dioneir_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (err) {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	} else {
+		if (pw->reset_gpio) {
+			if (gpio_cansleep(pw->reset_gpio))
+				gpio_set_value_cansleep(pw->reset_gpio, 0);
+			else
+				gpio_set_value(pw->reset_gpio, 0);
+		}
+
+		usleep_range(10, 10);
+
+		if (pw->dvdd)
+			regulator_disable(pw->dvdd);
+		if (pw->iovdd)
+			regulator_disable(pw->iovdd);
+		if (pw->avdd)
+			regulator_disable(pw->avdd);
+	}
+
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int dioneir_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->dvdd))
+		devm_regulator_put(pw->dvdd);
+
+	if (likely(pw->avdd))
+		devm_regulator_put(pw->avdd);
+
+	if (likely(pw->iovdd))
+		devm_regulator_put(pw->iovdd);
+
+	pw->dvdd = NULL;
+	pw->avdd = NULL;
+	pw->iovdd = NULL;
+
+	if (likely(pw->reset_gpio))
+		gpio_free(pw->reset_gpio);
+
+	return 0;
+}
+
+static int dioneir_power_get(struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct clk *parent;
+	int err = 0;
+
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	/* Sensor MCLK (aka. INCK) */
+	if (pdata->mclk_name) {
+		pw->mclk = devm_clk_get(dev, pdata->mclk_name);
+		if (IS_ERR(pw->mclk)) {
+			dev_err(dev, "unable to get clock %s\n",
+				pdata->mclk_name);
+			return PTR_ERR(pw->mclk);
+		}
+
+		if (pdata->parentclk_name) {
+			parent = devm_clk_get(dev, pdata->parentclk_name);
+			if (IS_ERR(parent)) {
+				dev_err(dev, "unable to get parent clock %s",
+					pdata->parentclk_name);
+			} else
+				clk_set_parent(pw->mclk, parent);
+		}
+	}
+
+	/* analog 2.8v */
+	if (pdata->regulators.avdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->avdd, pdata->regulators.avdd);
+	/* IO 1.8v */
+	if (pdata->regulators.iovdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->iovdd, pdata->regulators.iovdd);
+	/* dig 1.2v */
+	if (pdata->regulators.dvdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->dvdd, pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "%s: unable to get regulator(s)\n", __func__);
+		goto done;
+	}
+
+	/* Reset or ENABLE GPIO */
+	pw->reset_gpio = pdata->reset_gpio;
+	err = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+	if (err < 0) {
+		dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
+			__func__, err);
+		goto done;
+	}
+
+done:
+	pw->state = SWITCH_OFF;
+
+	return err;
+}
+
+static struct camera_common_pdata *dioneir_parse_dt(
+	struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	struct camera_common_pdata *ret = NULL;
+	int err = 0;
+	int gpio;
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(dioneir_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+		sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER)
+			ret = ERR_PTR(-EPROBE_DEFER);
+		dev_err(dev, "reset-gpios not found\n");
+		goto error;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	err = of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
+	if (err)
+		dev_dbg(dev, "mclk name not present, "
+			"assume sensor driven externally\n");
+
+	err = of_property_read_string(np, "avdd-reg",
+		&board_priv_pdata->regulators.avdd);
+	err |= of_property_read_string(np, "iovdd-reg",
+		&board_priv_pdata->regulators.iovdd);
+	err |= of_property_read_string(np, "dvdd-reg",
+		&board_priv_pdata->regulators.dvdd);
+	if (err)
+		dev_dbg(dev, "avdd, iovdd and/or dvdd reglrs. not present, "
+			"assume sensor powered independently\n");
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(np, "has-eeprom");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+
+	return ret;
+}
+
+static inline int tc358746_sleep_mode(struct regmap *regmap, int enable)
+{
+	return regmap_update_bits(regmap, SYSCTL, SYSCTL_SLEEP_MASK,
+				  enable ? SYSCTL_SLEEP_MASK : 0);
+}
+
+static inline int tc358746_sreset(struct regmap *regmap)
+{
+	int err;
+
+	err = regmap_write(regmap, SYSCTL, SYSCTL_SRESET_MASK);
+
+	udelay(10);
+
+	if (!err)
+		err = regmap_write(regmap, SYSCTL, 0);
+
+	return err;
+}
+
+static int tc358746_set_pll(struct regmap *regmap,
+			    u16 pll_prd, u16 pll_fbd, u16 pll_frs)
+{
+	u32 pllctl0, pllctl1, pllctl0_new;
+	int err;
+
+	err = regmap_read(regmap, PLLCTL0, &pllctl0);
+	if (!err)
+		err = regmap_read(regmap, PLLCTL1, &pllctl1);
+
+	if (err)
+		return err;
+
+	pllctl0_new = PLLCTL0_PLL_PRD_SET(pll_prd) |
+		PLLCTL0_PLL_FBD_SET(pll_fbd);
+
+	/*
+	 * Only rewrite when needed (new value or disabled), since rewriting
+	 * triggers another format change event.
+	 */
+
+	if (pllctl0 != pllctl0_new || (pllctl1 & PLLCTL1_PLL_EN_MASK) == 0) {
+		u16 pllctl1_mask = PLLCTL1_PLL_FRS_MASK | PLLCTL1_RESETB_MASK |
+				   PLLCTL1_PLL_EN_MASK;
+		u16 pllctl1_val = PLLCTL1_PLL_FRS_SET(pll_frs) |
+				  PLLCTL1_RESETB_MASK | PLLCTL1_PLL_EN_MASK;
+
+		err = regmap_write(regmap, PLLCTL0, pllctl0_new);
+		if (!err)
+			err = regmap_update_bits(regmap, PLLCTL1,
+						 pllctl1_mask, pllctl1_val);
+		udelay(1000);
+
+		if (!err)
+			err = regmap_update_bits(regmap, PLLCTL1,
+						 PLLCTL1_CKEN_MASK,
+						 PLLCTL1_CKEN_MASK);
+	}
+
+	return err;
+}
+
+static int tc358746_set_csi_color_space(struct regmap *regmap,
+		u8 pdformat, u8 pdataf)
+{
+	int err;
+
+	err = regmap_update_bits(regmap, DATAFMT,
+				 (DATAFMT_PDFMT_MASK | DATAFMT_UDT_EN_MASK),
+				 DATAFMT_PDFMT_SET(pdformat));
+
+	if (!err)
+		err = regmap_update_bits(regmap, CONFCTL, CONFCTL_PDATAF_MASK,
+					 CONFCTL_PDATAF_SET(pdataf));
+
+	return err;
+}
+
+static int tc358746_set_buffers(struct regmap *regmap,
+		u32 fmt_width, u8 bpp, u16 vb_fifo)
+{
+	unsigned int byte_per_line = (fmt_width * bpp) / 8;
+	int err;
+
+	err = regmap_write(regmap, FIFOCTL, vb_fifo);
+
+	if (!err)
+		err = regmap_write(regmap, WORDCNT, byte_per_line);
+
+	return err;
+}
+
+static int tc358746_enable_csi_lanes(struct regmap *regmap,
+		int lane_num, int enable)
+{
+	u32 val = 0;
+	int err = 0;
+
+	if (lane_num < 1 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, CLW_CNTRL,
+					   CLW_CNTRL_CLW_LANEDISABLE_MASK);
+		if (!err)
+			err = regmap_write(regmap, D0W_CNTRL,
+					   D0W_CNTRL_D0W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 2 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D1W_CNTRL,
+					   D1W_CNTRL_D1W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 3 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D2W_CNTRL,
+					   D2W_CNTRL_D2W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 4 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D3W_CNTRL,
+					   D2W_CNTRL_D3W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num > 0 && enable) {
+		val |= HSTXVREGEN_CLM_HSTXVREGEN_MASK |
+			HSTXVREGEN_D0M_HSTXVREGEN_MASK;
+	}
+
+	if (lane_num > 1 && enable)
+		val |= HSTXVREGEN_D1M_HSTXVREGEN_MASK;
+
+	if (lane_num > 2 && enable)
+		val |= HSTXVREGEN_D2M_HSTXVREGEN_MASK;
+
+	if (lane_num > 3 && enable)
+		val |= HSTXVREGEN_D3M_HSTXVREGEN_MASK;
+
+	if (!err)
+		err = regmap_write(regmap, HSTXVREGEN, val);
+
+	return err;
+}
+
+struct tc358746_csi_param {
+	bool is_continuous_clk;
+
+	/* CSI2-TX Parameters */
+	u32 lineinitcnt;
+	u32 lptxtimecnt;
+	u32 twakeupcnt;
+	u32 tclk_preparecnt;
+	u32 tclk_zerocnt;
+	u32 tclk_trailcnt;
+	u32 tclk_postcnt;
+	u32 ths_preparecnt;
+	u32 ths_zerocnt;
+	u32 ths_trailcnt;
+
+	u32 hstxvregcnt;
+};
+
+static void tc358746_csi_param_set_default(
+		struct tc358746_csi_param *param,
+		bool discontinuous_clk)
+{
+	param->is_continuous_clk = !discontinuous_clk;
+
+	param->lineinitcnt = 4000;
+	param->lptxtimecnt = 3;
+
+	param->tclk_preparecnt = 2;
+	param->tclk_zerocnt = 18;
+
+	/* default, skipped but value in excell = 0 */
+	param->tclk_trailcnt = 1;
+
+	param->ths_preparecnt = 3;
+	param->ths_zerocnt = 0;
+
+	param->twakeupcnt = 17000;
+
+	/* default, skipped but value in excell = 4 */
+	param->tclk_postcnt = 0;
+
+	param->ths_trailcnt = 1;
+
+	/* only presents in the excell, default: 32 */
+	param->hstxvregcnt = 5;
+}
+
+static int tc358746_set_csi(struct regmap *regmap,
+		struct tc358746_csi_param *param)
+{
+	u32 val;
+	int err;
+
+	val = TCLK_HEADERCNT_TCLK_ZEROCNT_SET(param->tclk_zerocnt) |
+	      TCLK_HEADERCNT_TCLK_PREPARECNT_SET(param->tclk_preparecnt);
+	err = regmap_write(regmap, TCLK_HEADERCNT, val);
+
+	val = THS_HEADERCNT_THS_ZEROCNT_SET(param->ths_zerocnt) |
+	      THS_HEADERCNT_THS_PREPARECNT_SET(param->ths_preparecnt);
+	if (!err)
+		err = regmap_write(regmap, THS_HEADERCNT, val);
+
+	if (!err)
+		err = regmap_write(regmap, TWAKEUP, param->twakeupcnt);
+
+	if (!err)
+		err = regmap_write(regmap, TCLK_POSTCNT, param->tclk_postcnt);
+
+	if (!err)
+		err = regmap_write(regmap, THS_TRAILCNT, param->ths_trailcnt);
+
+	if (!err)
+		err = regmap_write(regmap, LINEINITCNT, param->lineinitcnt);
+
+	if (!err)
+		err = regmap_write(regmap, LPTXTIMECNT, param->lptxtimecnt);
+
+	if (!err)
+		err = regmap_write(regmap, TCLK_TRAILCNT, param->tclk_trailcnt);
+
+	if (!err)
+		err = regmap_write(regmap, HSTXVREGCNT, param->hstxvregcnt);
+
+	val = param->is_continuous_clk ? TXOPTIONCNTRL_CONTCLKMODE_MASK : 0;
+	if (!err)
+		err = regmap_write(regmap, TXOPTIONCNTRL, val);
+
+	return err;
+}
+
+static int tc38764_debug_pattern_80(struct regmap *regmap)
+{
+	int i, err;
+
+	err = regmap_write(regmap, DBG_ACT_LINE_CNT, 0x8000);
+	if (!err)
+		err = regmap_write(regmap, DBG_LINE_WIDTH, 0x0821);
+	if (!err)
+		err = regmap_write(regmap, DBG_VERT_BLANK_LINE_CNT, 0);
+
+	/* White 80pixel */
+	for (i = 0; i < 120 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+	}
+
+	/* Yellow 80pixel, BGR: 00 FF FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+	}
+
+	/* Cyan 80pixel, BGR: FF FF 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+	}
+
+	/* Green 80pixel, BGR: 00 FF 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+	}
+
+	/* Magenda 80pixel, BGR: FF 00 FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+	}
+
+	/* Red 80pixel, BGR: 00 00 FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+	}
+
+	/* Blue 80pixel, BGR: FF 00 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+	}
+
+	/* Black 80pixel */
+	for (i = 0; i < 120 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+	}
+
+	return err;
+}
+
+static int tc358746_wr_csi_control(struct regmap *regmap, u32 val)
+{
+	u32 _val;
+
+	val &= CSI_CONFW_DATA_MASK;
+	_val = CSI_CONFW_MODE_SET_MASK | CSI_CONFW_ADDRESS_CSI_CONTROL_MASK |
+		val;
+
+	return regmap_write(regmap, CSI_CONFW, _val);
+}
+
+static int tc358746_enable_csi_module(struct regmap *regmap, int lane_num)
+{
+	u32 val;
+	int err;
+
+	err = regmap_write(regmap, STARTCNTRL, STARTCNTRL_START_MASK);
+
+	if (!err)
+		err = regmap_write(regmap, CSI_START, CSI_START_STRT_MASK);
+
+	val = CSI_CONTROL_NOL_1_MASK;
+	if (lane_num == 2)
+		val = CSI_CONTROL_NOL_2_MASK;
+	else if (lane_num == 3)
+		val = CSI_CONTROL_NOL_3_MASK;
+	else if (lane_num == 4)
+		val = CSI_CONTROL_NOL_4_MASK;
+
+	val |= CSI_CONTROL_CSI_MODE_MASK | CSI_CONTROL_TXHSMD_MASK |
+		CSI_CONTROL_EOTDIS_MASK; /* add according to excell */
+
+	if (!err)
+		err = tc358746_wr_csi_control(regmap, val);
+
+	return err;
+}
+
+static int dioneir_set_mode(struct tegracam_device *tc_dev)
+{
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	struct regmap *tx_regmap = priv->tx_regmap;
+	int err;
+
+	/* Parameters:
+	 *
+	 * 1. pll setup:
+	 * - pll_prd: Pre Divider value // calc
+	 * - pll_fbd: Multiply value of Unit Clock // calc
+	 * - pll_frs: CSI speed/lane // calc
+	 *
+	 * 2. setup format: RGB888
+	 * - pdformat: 0x3 // dt
+	 * - pdataformat: 0x0 // dt
+	 *
+	 * 3. setup buffers:
+	 * - fmt_width = 640 // dt
+	 * - bpp = 24 (bits per pixel) // dt
+	 * - vb_fifo = 247 (fifo size) // calc
+	 *
+	 * 4. setup csi lanes
+	 * - lane_num = 2 // dt
+	 * - struct tc358746_csi_param // calc
+	 * - discontinuous_clk = true // dt
+	 *
+	 * 5. test_mode
+	 */
+	u16 pll_prd = 3, pll_fbd = 82, pll_frs = 1;
+	u8 pdformat = 0x3, pdataf = 0x0;
+	u32 fmt_width = 640; u8 bpp = 24; u16 vb_fifo = 247;
+	int lane_num = 2;
+	struct tc358746_csi_param csi_setting;
+	bool discontinuous_clk = true;
+
+	tc358746_csi_param_set_default(&csi_setting, discontinuous_clk);
+
+	regmap_write(ctl_regmap, DBG_ACT_LINE_CNT, 0);
+
+	err = tc358746_sreset(ctl_regmap);
+	if (err) {
+		dev_err(tc_dev->dev, "Failed to reset chip\n");
+		return err;
+	}
+
+	err = tc358746_set_pll(ctl_regmap, pll_prd, pll_fbd, pll_frs);
+	if (err) {
+		dev_err(tc_dev->dev, "Failed to setup PLL\n");
+		return err;
+	}
+
+	err = tc358746_set_csi_color_space(ctl_regmap, pdformat, pdataf);
+
+	if (!err)
+		err = tc358746_set_buffers(ctl_regmap, fmt_width, bpp, vb_fifo);
+
+	if (!err)
+		err = tc358746_enable_csi_lanes(tx_regmap, lane_num, true);
+
+	if (!err)
+		err = tc358746_set_csi(tx_regmap, &csi_setting);
+
+	if (!err && test_mode)
+		err = tc38764_debug_pattern_80(ctl_regmap);
+
+	if (!err)
+		err = tc358746_enable_csi_module(tx_regmap, lane_num);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static int dioneir_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	int err;
+
+	err = regmap_write(ctl_regmap, PP_MISC, 0);
+	if (test_mode) {
+		if (!err)
+			err = regmap_write(ctl_regmap, DBG_ACT_LINE_CNT, 0xc1df);
+	} else {
+		if (!err)
+			err = regmap_update_bits(ctl_regmap, CONFCTL,
+						 CONFCTL_PPEN_MASK,
+						 CONFCTL_PPEN_MASK);
+	}
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static int dioneir_stop_streaming(struct tegracam_device *tc_dev)
+{
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	struct regmap *tx_regmap = priv->tx_regmap;
+	int err;
+
+	err = regmap_update_bits(ctl_regmap, PP_MISC, PP_MISC_FRMSTOP_MASK,
+				 PP_MISC_FRMSTOP_MASK);
+	if (!err)
+		err = regmap_update_bits(ctl_regmap, CONFCTL,
+					 CONFCTL_PPEN_MASK, 0);
+
+	if (!err)
+		err = regmap_update_bits(ctl_regmap, PP_MISC,
+					 PP_MISC_RSTPTR_MASK,
+					 PP_MISC_RSTPTR_MASK);
+
+	if (!err)
+		err = regmap_write(tx_regmap, CSIRESET,
+				   (CSIRESET_RESET_CNF_MASK |
+				    CSIRESET_RESET_MODULE_MASK));
+	if (!err)
+		err = regmap_write(ctl_regmap, DBG_ACT_LINE_CNT, 0);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static struct camera_common_sensor_ops dioneir_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(dioneir_frmfmt),
+	.frmfmt_table = dioneir_frmfmt,
+	.power_on = dioneir_power_on,
+	.power_off = dioneir_power_off,
+	.write_reg = dioneir_write_reg,
+	.read_reg = dioneir_read_reg,
+	.parse_dt = dioneir_parse_dt,
+	.power_get = dioneir_power_get,
+	.power_put = dioneir_power_put,
+	.set_mode = dioneir_set_mode,
+	.start_streaming = dioneir_start_streaming,
+	.stop_streaming = dioneir_stop_streaming,
+};
+
+static int dioneir_board_setup(struct dione_struct *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	struct regmap *ctl_regmap = s_data->regmap;
+	u32 reg_val;
+	int err = 0;
+
+	if (pdata->mclk_name) {
+		err = camera_common_mclk_enable(s_data);
+		if (err) {
+			dev_err(dev, "error turning on mclk (%d)\n", err);
+			goto done;
+		}
+	}
+
+	err = dioneir_power_on(s_data);
+	if (err) {
+		dev_err(dev, "error during power on sensor (%d)\n", err);
+		goto err_power_on;
+	}
+
+	/* Probe sensor model id registers */
+	err = regmap_read(ctl_regmap, CHIPID, &reg_val);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+
+	if ((reg_val & CHIPID_CHIPID_MASK) != 0x4400) {
+		dev_err(dev, "%s: invalid sensor model id: %x\n",
+			__func__, reg_val);
+		err = -ENODEV;
+		goto err_reg_probe;
+	}
+
+err_reg_probe:
+	dioneir_power_off(s_data);
+
+err_power_on:
+	if (pdata->mclk_name)
+		camera_common_mclk_disable(s_data);
+
+done:
+	return err;
+}
+
+static int dioneir_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops dioneir_subdev_internal_ops = {
+	.open = dioneir_open,
+};
+
+static int dioneir_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tegracam_device *tc_dev;
+	struct dione_struct *priv;
+	int err;
+
+	dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(dev, sizeof(struct dione_struct), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return -ENOMEM;
+
+	priv->i2c_client = tc_dev->client = client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "dione_ir", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &ctl_regmap_config;
+	tc_dev->sensor_ops = &dioneir_common_ops;
+	tc_dev->v4l2sd_internal_ops = &dioneir_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &dioneir_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		dev_err(dev, "tegra camera driver registration failed\n");
+		return err;
+	}
+
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+
+	priv->tx_regmap = devm_regmap_init_i2c(client,
+					       &tx_regmap_config);
+	if (IS_ERR(priv->tx_regmap)) {
+		dev_err(dev, "tx_regmap init failed: %ld\n",
+			PTR_ERR(priv->tx_regmap));
+		tegracam_device_unregister(tc_dev);
+		return -ENODEV;
+	}
+
+	err = dioneir_board_setup(priv);
+	if (err) {
+		tegracam_device_unregister(tc_dev);
+		dev_err(dev, "board setup failed\n");
+		return err;
+	}
+
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
+		tegracam_device_unregister(tc_dev);
+		return err;
+	}
+
+	dev_info(dev, "detected Dione IR sensor\n");
+
+	return 0;
+}
+
+static int dioneir_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct dione_struct *priv = (struct dione_struct *)s_data->priv;
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id dioneir_id[] = {
+	{ "dione_ir", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, dioneir_id);
+
+static struct i2c_driver dioneir_i2c_driver = {
+	.driver = {
+		.name = "dione_ir",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(dioneir_of_match),
+	},
+	.probe = dioneir_probe,
+	.remove = dioneir_remove,
+	.id_table = dioneir_id,
+};
+module_i2c_driver(dioneir_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Xenics Dione640 and Dione1280");
+MODULE_AUTHOR("Xenics Infrared Solutions / Botond Kardos");
+MODULE_LICENSE("GPL v2");
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione-ir.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione-ir.dtsi
new file mode 100644
index 000000000000..d4f03ed52bf3
--- /dev/null
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione-ir.dtsi
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) 2021, Xenics Infrared Solutions.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <dt-bindings/media/camera.h>
+#include <dt-bindings/platform/t210/t210.h>
+
+/ {
+	host1x {
+		vi_base: vi {
+			num-channels = <1>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				vi_port0: port@0 {
+					reg = <0>;
+					rbpcv2_dione_ir_vi_in0: endpoint {
+						port-index = <0>;
+						bus-width = <2>;
+						remote-endpoint = <&rbpcv2_dione_ir_csi_out0>;
+					};
+				};
+			};
+		};
+
+		csi_base: nvcsi {
+			num-channels = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			csi_chan0: channel@0 {
+				reg = <0>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan0_port0: port@0 {
+						reg = <0>;
+						rbpcv2_dione_ir_csi_in0: endpoint@0 {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_dione_ir_out0>;
+						};
+					};
+					csi_chan0_port1: port@1 {
+						reg = <1>;
+						rbpcv2_dione_ir_csi_out0: endpoint@1 {
+							remote-endpoint = <&rbpcv2_dione_ir_vi_in0>;
+						};
+					};
+				};
+			};
+		};
+
+		i2c@546c0000 {
+			dione_ir_single_cam0: rbpcv2_dione_ir_a@0e {
+				compatible = "xenics,dione_ir";
+				/* I2C device address */
+				reg = <0x0e>;
+
+				/* V4L2 device node location */
+				devnode = "video0";
+
+				/* Physical dimensions of sensor */
+				physical_w = "7.680";
+				physical_h = "5.760";
+
+				sensor_model = "dione_ir";
+
+				use_sensor_mode_id = "true";
+
+				/**
+				* ==== Modes ====
+				* A modeX node is required to support v4l2 driver
+				* implementation with NVIDIA camera software stack
+				*
+				* == Signal properties ==
+				*
+				* phy_mode = "";
+				* PHY mode used by the MIPI lanes for this device
+				*
+				* tegra_sinterface = "";
+				* CSI Serial interface connected to tegra
+				* Incase of virtual HW devices, use virtual
+				* For SW emulated devices, use host
+				*
+				* pix_clk_hz = "";
+				* Sensor pixel clock used for calculations like exposure and framerate
+				*
+				* readout_orientation = "0";
+				* Based on camera module orientation.
+				* Only change readout_orientation if you specifically
+				* Program a different readout order for this mode
+				*
+				* == Image format Properties ==
+				*
+				* active_w = "";
+				* Pixel active region width
+				*
+				* active_h = "";
+				* Pixel active region height
+				*
+				* pixel_t = "";
+				* The sensor readout pixel pattern
+				*
+				* line_length = "";
+				* Pixel line length (width) for sensor mode.
+				*
+				* == Source Control Settings ==
+				*
+				* Gain factor used to convert fixed point integer to float
+				* Gain range [min_gain/gain_factor, max_gain/gain_factor]
+				* Gain step [step_gain/gain_factor is the smallest step that can be configured]
+				* Default gain [Default gain to be initialized for the control.
+				*     use min_gain_val as default for optimal results]
+				* Framerate factor used to convert fixed point integer to float
+				* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
+				* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
+				* Default Framerate [Default framerate to be initialized for the control.
+				*     use max_framerate to get required performance]
+				* Exposure factor used to convert fixed point integer to float
+				* For convenience use 1 sec = 1000000us as conversion factor
+				* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
+				* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
+				* Default Exposure Time [Default exposure to be initialized for the control.
+				*     Set default exposure based on the default_framerate for optimal exposure settings]
+				*
+				* gain_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_gain_val = ""; (ceil to integer)
+				* max_gain_val = ""; (ceil to integer)
+				* step_gain_val = ""; (ceil to integer)
+				* default_gain = ""; (ceil to integer)
+				* Gain limits for mode
+				*
+				* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_exp_time = ""; (ceil to integer)
+				* max_exp_time = ""; (ceil to integer)
+				* step_exp_time = ""; (ceil to integer)
+				* default_exp_time = ""; (ceil to integer)
+				* Exposure Time limits for mode (sec)
+				*
+				* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_framerate = ""; (ceil to integer)
+				* max_framerate = ""; (ceil to integer)
+				* step_framerate = ""; (ceil to integer)
+				* default_framerate = ""; (ceil to integer)
+				* Framerate limits for mode (fps)
+				*
+				* embedded_metadata_height = "";
+				* Sensor embedded metadata height in units of rows.
+				* If sensor does not support embedded metadata value should be 0.
+				*/
+				mode0 { /* DIONE_IR_MODE_640x480_60FPS */
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_a";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes";
+					dpcm_enable = "false";
+					cil_settletime = "0";
+
+					active_w = "640";
+					active_h = "480";
+					pixel_t = "rgb_rgb88824";
+					readout_orientation = "0";
+					line_length = "694";
+					/* inherent_gain = "1"; */
+					/* mclk_multiplier = "9.33"; */
+					pix_clk_hz = "20000000";
+
+					/* unused */
+					gain_factor = "16";
+					exposure_factor = "1000000";
+					min_gain_val = "16"; /* 1.00x */
+					max_gain_val = "170"; /* 10.66x */
+					step_gain_val = "1";
+					default_gain = "16"; /* 1.00x */
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+
+					/* framerate */
+					framerate_factor = "1000000";
+					min_framerate = "40000000"; /* 40 fps */
+					max_framerate = "62000000"; /* 62 fps */
+					step_framerate = "1";
+					default_framerate = "60020000"; /* 60.020 fps */
+
+					/* unused */
+					min_exp_time = "13"; /* us */
+					max_exp_time = "683709"; /* us */
+					step_exp_time = "1";
+					default_exp_time = "2495"; /* us */
+
+					embedded_metadata_height = "0";
+				};
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						rbpcv2_dione_ir_out0: endpoint {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_dione_ir_csi_in0>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	/* CN 3423-xx SN xxxx 55mm F/1 */
+	lens_dione_ir@RBPCV2 {
+		min_focus_distance = "2000.0"; /* F.R 2m ~ ... */
+		hyper_focal = "0.0";
+		focal_length = "55.0"; /* E.F.L 55mm */
+		f_number = "1.0"; /* F.NO 1.0 */
+		aperture = "0.0";
+	};
+};
+
+/ {
+	tcp: tegra-camera-platform {
+		compatible = "nvidia, tegra-camera-platform";
+
+		/**
+		* Physical settings to calculate max ISO BW
+		*
+		* num_csi_lanes = <>;
+		* Total number of CSI lanes when all cameras are active
+		*
+		* max_lane_speed = <>;
+		* Max lane speed in Kbit/s
+		*
+		* min_bits_per_pixel = <>;
+		* Min bits per pixel
+		*
+		* vi_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the VI ISO case
+		*
+		* vi_bw_margin_pct = <>;
+		* Vi bandwidth margin in percentage
+		*
+		* max_pixel_rate = <>;
+		* Max pixel rate in Kpixel/s for the ISP ISO case
+		*
+		* isp_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the ISP ISO case
+		*
+		* isp_bw_margin_pct = <>;
+		* Isp bandwidth margin in percentage
+		*/
+		num_csi_lanes = <2>;
+		max_lane_speed = <1500000>;
+		min_bits_per_pixel = <10>;
+		vi_peak_byte_per_pixel = <2>;
+		vi_bw_margin_pct = <25>;
+		max_pixel_rate = <240000>;
+		isp_peak_byte_per_pixel = <5>;
+		isp_bw_margin_pct = <25>;
+
+		/**
+		 * The general guideline for naming badge_info contains 3 parts, and is as follows,
+		 * The first part is the camera_board_id for the module; if the module is in a FFD
+		 * platform, then use the platform name for this part.
+		 * The second part contains the position of the module, ex. "rear" or "front".
+		 * The third part contains the last 6 characters of a part number which is found
+		 * in the module's specsheet from the vendor.
+		 */
+		modules {
+			cam_module0: module0 {
+				badge = "porg_front_RBPCV2";
+				position = "front";
+				orientation = "1";
+				cam_module0_drivernode0: drivernode0 {
+					pcl_id = "v4l2_sensor";
+					devname = "dione_ir 6-000e";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione_ir_a@0e";
+				};
+				cam_module0_drivernode1: drivernode1 {
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_dione_ir@RBPCV2/";
+				};
+			};
+		};
+	};
+};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi
new file mode 100644
index 000000000000..c896b3633e82
--- /dev/null
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2018-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "tegra210-camera-rbpcv2-dione-ir.dtsi"
+
+#define CAM1_PWDN		TEGRA_GPIO(S, 7)
+
+/ {
+    host1x {
+		i2c@546c0000 {
+			clock-frequency = <1000000>;
+
+			rbpcv2_dione_ir_a@0e {
+				status = "disabled";
+				reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+
+    gpio@6000d000 {
+		camera-control-output-low {
+			gpio-hog;
+			output-low;
+			gpios = < CAM1_PWDN 0 >;
+			label = "cam1-pwdn";
+		};
+	};
+};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
index 7b2127cbaa3c..9e3a5d5deaff 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
@@ -237,6 +237,57 @@
 				};
 			};
 
+			/* dione_ir single sensor module */
+			override@9 {
+				target = <&dione_ir_single_cam0>;
+				_overlay_ {
+					status = "okay";
+				};
+			};
+			override@10 {
+				target = <&cam_module0_drivernode0>;
+				_overlay_ {
+					status = "okay";
+					pcl_id = "v4l2_sensor";
+					devname = "dione_ir 6-000e";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione_ir_a@0e";
+				};
+			};
+			override@11 {
+				target = <&cam_module0_drivernode1>;
+				_overlay_ {
+					status = "okay";
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_dione_ir@RBPCV2/";
+				};
+			};
+			override@12 {
+				target = <&rbpcv2_dione_ir_vi_in0>;
+				_overlay_ {
+					status = "okay";
+					port-index = <0>;
+					bus-width = <2>;
+					remote-endpoint = <&rbpcv2_dione_ir_csi_out0>;
+				};
+			};
+			override@13 {
+				target = <&rbpcv2_dione_ir_csi_in0>;
+				_overlay_ {
+					status = "okay";
+					port-index = <0>;
+					bus-width = <2>;
+					remote-endpoint = <&rbpcv2_dione_ir_out0>;
+				};
+			};
+			override@14 {
+				target = <&rbpcv2_dione_ir_csi_out0>;
+				_overlay_ {
+					status = "okay";
+					remote-endpoint = <&rbpcv2_dione_ir_vi_in0>;
+				};
+			};
+
+
 			/* tegra-camera-platform settings */
 			override@20 {
 				target = <&tcp>;
diff --git a/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi b/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
index 841c38006073..b0eafec495df 100644
--- a/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
@@ -30,6 +30,7 @@
 #include "porg-platforms/tegra210-porg-camera.dtsi"
 #include "porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi"
 #include "porg-platforms/tegra210-porg-camera-rbpcv2-dione1280.dtsi"
+#include "porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi"
 #include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
 #include <t210-common-platforms/tegra210-ers-hdmi-e2190-1100-a00.dtsi>
 #include <t210-common-platforms/tegra210-dp.dtsi>
-- 
2.25.1

