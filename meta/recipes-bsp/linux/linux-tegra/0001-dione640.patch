commit 6f7461a345f60bcb2b4ad6630f373f291ccf311b
Author: Botond Kardos <bkardos70@gmail.com>
Date:   Fri Oct 22 10:20:40 2021 +0200

    dione640 driver added

diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c
index 4965abd6c6c9..17f304371c5b 100644
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@ -263,6 +263,30 @@ static void regmap_format_32_le(void *buf, unsigned int val, unsigned int shift)
 	b[0] = cpu_to_le32(val << shift);
 }
 
+static void regmap_format_32_lbe(void *buf, unsigned int val, unsigned int shift)
+{
+	u8 *b = buf;
+
+	val <<= shift;
+
+	b[0] = val >> 16;
+	b[1] = val >> 24;
+	b[2] = val;
+	b[3] = val >> 8;
+}
+
+static void regmap_format_32_ble(void *buf, unsigned int val, unsigned int shift)
+{
+	u8 *b = buf;
+
+	val <<= shift;
+
+	b[0] = val >> 8;
+	b[1] = val;
+	b[2] = val >> 24;
+	b[3] = val >> 16;
+}
+
 static void regmap_format_32_native(void *buf, unsigned int val,
 				    unsigned int shift)
 {
@@ -359,6 +383,28 @@ static unsigned int regmap_parse_32_le(const void *buf)
 	return le32_to_cpu(b[0]);
 }
 
+static unsigned int regmap_parse_32_lbe(const void *buf)
+{
+	const u8 *b = buf;
+	unsigned int ret = b[2];
+	ret |= ((unsigned int)b[3]) << 8;
+	ret |= ((unsigned int)b[0]) << 16;
+	ret |= ((unsigned int)b[1]) << 24;
+
+	return ret;
+}
+
+static unsigned int regmap_parse_32_ble(const void *buf)
+{
+	const u8 *b = buf;
+	unsigned int ret = b[1];
+	ret |= ((unsigned int)b[0]) << 8;
+	ret |= ((unsigned int)b[3]) << 16;
+	ret |= ((unsigned int)b[2]) << 24;
+
+	return ret;
+}
+
 static void regmap_parse_32_be_inplace(void *buf)
 {
 	__be32 *b = buf;
@@ -373,6 +419,20 @@ static void regmap_parse_32_le_inplace(void *buf)
 	b[0] = le32_to_cpu(b[0]);
 }
 
+static void regmap_parse_32_lbe_inplace(void *buf)
+{
+	u32 *b = buf;
+
+	b[0] = regmap_parse_32_lbe(buf);
+}
+
+static void regmap_parse_32_ble_inplace(void *buf)
+{
+	u32 *b = buf;
+
+	b[0] = regmap_parse_32_ble(buf);
+}
+
 static unsigned int regmap_parse_32_native(const void *buf)
 {
 	return *(u32 *)buf;
@@ -875,6 +935,16 @@ struct regmap *__regmap_init(struct device *dev,
 			map->format.parse_val = regmap_parse_32_le;
 			map->format.parse_inplace = regmap_parse_32_le_inplace;
 			break;
+		case REGMAP_ENDIAN_LITTLE_BIG:
+			map->format.format_val = regmap_format_32_lbe;
+			map->format.parse_val = regmap_parse_32_lbe;
+			map->format.parse_inplace = regmap_parse_32_lbe_inplace;
+			break;
+		case REGMAP_ENDIAN_BIG_LITTLE:
+			map->format.format_val = regmap_format_32_ble;
+			map->format.parse_val = regmap_parse_32_ble;
+			map->format.parse_inplace = regmap_parse_32_ble_inplace;
+			break;
 		case REGMAP_ENDIAN_NATIVE:
 			map->format.format_val = regmap_format_32_native;
 			map->format.parse_val = regmap_parse_32_native;
diff --git a/include/linux/regmap.h b/include/linux/regmap.h
index e85d110fbdfb..5caae1ca4966 100644
--- a/include/linux/regmap.h
+++ b/include/linux/regmap.h
@@ -143,6 +143,10 @@ enum regmap_endian {
 	REGMAP_ENDIAN_BIG,
 	REGMAP_ENDIAN_LITTLE,
 	REGMAP_ENDIAN_NATIVE,
+	/* Mixed endian: be words in le order (like on PDP-11), 2-1-4-3 */
+	REGMAP_ENDIAN_BIG_LITTLE,
+	/* Mixed endian: le words in be order, 3-4-1-2 */
+	REGMAP_ENDIAN_LITTLE_BIG,
 };
 
 /**
diff --git a/nvidia/drivers/media/i2c/Kconfig b/nvidia/drivers/media/i2c/Kconfig
index 326dbb096017..d39d4b0855ef 100644
--- a/nvidia/drivers/media/i2c/Kconfig
+++ b/nvidia/drivers/media/i2c/Kconfig
@@ -3,6 +3,15 @@ if VIDEO_V4L2
 menu "NVIDIA overlay Encoders, decoders, sensors and other helper chips"
 	visible if !MEDIA_SUBDRV_AUTOSELECT || COMPILE_TEST
 
+config VIDEO_DIONE640
+	tristate "DIONE640 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This driver supports DIONE640 infra camera sensor from Xenics
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called dione640.
+
 config VIDEO_IMX185
 	tristate "IMX185 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/nvidia/drivers/media/i2c/Makefile b/nvidia/drivers/media/i2c/Makefile
index c6d34e8077e3..dfd602e4b367 100644
--- a/nvidia/drivers/media/i2c/Makefile
+++ b/nvidia/drivers/media/i2c/Makefile
@@ -21,3 +21,4 @@ obj-$(CONFIG_VIDEO_LT6911UXC) +=lt6911uxc.o
 obj-$(CONFIG_I2C_IOEXPANDER_SER_MAX9295) += max9295.o
 obj-$(CONFIG_I2C_IOEXPANDER_DESER_MAX9296) += max9296.o
 obj-$(CONFIG_VIDEO_IMX390) += imx390.o
+obj-$(CONFIG_VIDEO_DIONE640) += dione640.o
diff --git a/nvidia/drivers/media/i2c/dione640.c b/nvidia/drivers/media/i2c/dione640.c
new file mode 100644
index 000000000000..c1c7f2c6dc87
--- /dev/null
+++ b/nvidia/drivers/media/i2c/dione640.c
@@ -0,0 +1,1099 @@
+/*
+ * dione640.c - dione640 sensor driver
+ *
+ * Copyright (c) 2015-2020, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegracam_core.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "tc358746_regs.h"
+
+static int test_mode = 0;
+module_param(test_mode, int, 0644);
+
+enum {
+	DIONE640_MODE_640x480_60FPS,
+};
+
+static const int dione640_60fps[] = {
+	60,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in
+ * device tree!
+ */
+static const struct camera_common_frmfmt dione640_frmfmt[] = {
+	{{640, 480},	dione640_60fps, 1, 0, DIONE640_MODE_640x480_60FPS},
+	/* Add modes with no device tree support after below */
+};
+
+static const struct regmap_range ctl_regmap_rw_ranges[] = {
+	regmap_reg_range(0x0000, 0x00ff),
+};
+
+static const struct regmap_access_table ctl_regmap_access = {
+	.yes_ranges = ctl_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(ctl_regmap_rw_ranges),
+};
+
+static const struct regmap_config ctl_regmap_config = {
+	.reg_bits = 16,
+	.reg_stride = 2,
+	.val_bits = 16,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0x00ff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.rd_table = &ctl_regmap_access,
+	.wr_table = &ctl_regmap_access,
+	.name = "tc358746-ctl",
+};
+
+static const struct regmap_range tx_regmap_rw_ranges[] = {
+	regmap_reg_range(0x0100, 0x05ff),
+};
+
+static const struct regmap_access_table tx_regmap_access = {
+	.yes_ranges = tx_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(tx_regmap_rw_ranges),
+};
+
+static const struct regmap_config tx_regmap_config = {
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0x05ff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG_LITTLE,
+	.rd_table = &tx_regmap_access,
+	.wr_table = &tx_regmap_access,
+	.name = "tc358746-tx",
+};
+
+static const struct of_device_id dione640_of_match[] = {
+	{ .compatible = "xenics,dione64", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, dione640_of_match);
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+};
+
+struct dione640 {
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	struct regmap			*tx_regmap;
+	struct camera_common_data	*s_data;
+	struct tegracam_device		*tc_dev;
+};
+
+static inline int dione640_read_reg(struct camera_common_data *s_data,
+	u16 addr, u8 *val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xff;
+
+	return err;
+}
+
+static inline int dione640_write_reg(struct camera_common_data *s_data,
+	u16 addr, u8 val)
+{
+	int err = 0;
+
+	err = regmap_write(s_data->regmap, addr, val);
+	if (err)
+		dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int dione640_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%d\n", __func__, val);
+	return 0;
+}
+
+static int dione640_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static int dione640_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static int dione640_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static struct tegracam_ctrl_ops dione640_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.set_gain = dione640_set_gain,
+	.set_exposure = dione640_set_exposure,
+	.set_frame_rate = dione640_set_frame_rate,
+	.set_group_hold = dione640_set_group_hold,
+};
+
+static int dione640_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 0);
+		else
+			gpio_set_value(pw->reset_gpio, 0);
+	}
+
+	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
+		goto skip_power_seqn;
+
+	usleep_range(10, 20);
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		if (err)
+			goto dione640_avdd_fail;
+	}
+
+	if (pw->iovdd) {
+		err = regulator_enable(pw->iovdd);
+		if (err)
+			goto dione640_iovdd_fail;
+	}
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		if (err)
+			goto dione640_dvdd_fail;
+	}
+
+	usleep_range(10, 20);
+
+skip_power_seqn:
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 1);
+		else
+			gpio_set_value(pw->reset_gpio, 1);
+	}
+
+	usleep_range(23000, 23100);
+
+	pw->state = SWITCH_ON;
+
+	return 0;
+
+dione640_dvdd_fail:
+	regulator_disable(pw->iovdd);
+
+dione640_iovdd_fail:
+	regulator_disable(pw->avdd);
+
+dione640_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+
+	return -ENODEV;
+}
+
+static int dione640_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (err) {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	} else {
+		if (pw->reset_gpio) {
+			if (gpio_cansleep(pw->reset_gpio))
+				gpio_set_value_cansleep(pw->reset_gpio, 0);
+			else
+				gpio_set_value(pw->reset_gpio, 0);
+		}
+
+		usleep_range(10, 10);
+
+		if (pw->dvdd)
+			regulator_disable(pw->dvdd);
+		if (pw->iovdd)
+			regulator_disable(pw->iovdd);
+		if (pw->avdd)
+			regulator_disable(pw->avdd);
+	}
+
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int dione640_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->dvdd))
+		devm_regulator_put(pw->dvdd);
+
+	if (likely(pw->avdd))
+		devm_regulator_put(pw->avdd);
+
+	if (likely(pw->iovdd))
+		devm_regulator_put(pw->iovdd);
+
+	pw->dvdd = NULL;
+	pw->avdd = NULL;
+	pw->iovdd = NULL;
+
+	if (likely(pw->reset_gpio))
+		gpio_free(pw->reset_gpio);
+
+	return 0;
+}
+
+static int dione640_power_get(struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct clk *parent;
+	int err = 0;
+
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	/* Sensor MCLK (aka. INCK) */
+	if (pdata->mclk_name) {
+		pw->mclk = devm_clk_get(dev, pdata->mclk_name);
+		if (IS_ERR(pw->mclk)) {
+			dev_err(dev, "unable to get clock %s\n",
+				pdata->mclk_name);
+			return PTR_ERR(pw->mclk);
+		}
+
+		if (pdata->parentclk_name) {
+			parent = devm_clk_get(dev, pdata->parentclk_name);
+			if (IS_ERR(parent)) {
+				dev_err(dev, "unable to get parent clock %s",
+					pdata->parentclk_name);
+			} else
+				clk_set_parent(pw->mclk, parent);
+		}
+	}
+
+	/* analog 2.8v */
+	if (pdata->regulators.avdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->avdd, pdata->regulators.avdd);
+	/* IO 1.8v */
+	if (pdata->regulators.iovdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->iovdd, pdata->regulators.iovdd);
+	/* dig 1.2v */
+	if (pdata->regulators.dvdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->dvdd, pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "%s: unable to get regulator(s)\n", __func__);
+		goto done;
+	}
+
+	/* Reset or ENABLE GPIO */
+	pw->reset_gpio = pdata->reset_gpio;
+	err = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+	if (err < 0) {
+		dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
+			__func__, err);
+		goto done;
+	}
+
+done:
+	pw->state = SWITCH_OFF;
+
+	return err;
+}
+
+static struct camera_common_pdata *dione640_parse_dt(
+	struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	struct camera_common_pdata *ret = NULL;
+	int err = 0;
+	int gpio;
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(dione640_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+		sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER)
+			ret = ERR_PTR(-EPROBE_DEFER);
+		dev_err(dev, "reset-gpios not found\n");
+		goto error;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	err = of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
+	if (err)
+		dev_dbg(dev, "mclk name not present, "
+			"assume sensor driven externally\n");
+
+	err = of_property_read_string(np, "avdd-reg",
+		&board_priv_pdata->regulators.avdd);
+	err |= of_property_read_string(np, "iovdd-reg",
+		&board_priv_pdata->regulators.iovdd);
+	err |= of_property_read_string(np, "dvdd-reg",
+		&board_priv_pdata->regulators.dvdd);
+	if (err)
+		dev_dbg(dev, "avdd, iovdd and/or dvdd reglrs. not present, "
+			"assume sensor powered independently\n");
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(np, "has-eeprom");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+
+	return ret;
+}
+
+static inline int tc358746_sleep_mode(struct regmap *regmap, int enable)
+{
+	return regmap_update_bits(regmap, SYSCTL, SYSCTL_SLEEP_MASK,
+				  enable ? SYSCTL_SLEEP_MASK : 0);
+}
+
+static inline int tc358746_sreset(struct regmap *regmap)
+{
+	int err;
+
+	err = regmap_write(regmap, SYSCTL, SYSCTL_SRESET_MASK);
+
+	udelay(10);
+
+	if (!err)
+		err = regmap_write(regmap, SYSCTL, 0);
+
+	return err;
+}
+
+static int tc358746_set_pll(struct regmap *regmap,
+			    u16 pll_prd, u16 pll_fbd, u16 pll_frs)
+{
+	u32 pllctl0, pllctl1, pllctl0_new;
+	int err;
+
+	err = regmap_read(regmap, PLLCTL0, &pllctl0);
+	if (!err)
+		err = regmap_read(regmap, PLLCTL1, &pllctl1);
+
+	if (err)
+		return err;
+
+	pllctl0_new = PLLCTL0_PLL_PRD_SET(pll_prd) |
+		PLLCTL0_PLL_FBD_SET(pll_fbd);
+
+	/*
+	 * Only rewrite when needed (new value or disabled), since rewriting
+	 * triggers another format change event.
+	 */
+
+	if (pllctl0 != pllctl0_new || (pllctl1 & PLLCTL1_PLL_EN_MASK) == 0) {
+		u16 pllctl1_mask = PLLCTL1_PLL_FRS_MASK | PLLCTL1_RESETB_MASK |
+				   PLLCTL1_PLL_EN_MASK;
+		u16 pllctl1_val = PLLCTL1_PLL_FRS_SET(pll_frs) |
+				  PLLCTL1_RESETB_MASK | PLLCTL1_PLL_EN_MASK;
+
+		err = regmap_write(regmap, PLLCTL0, pllctl0_new);
+		if (!err)
+			err = regmap_update_bits(regmap, PLLCTL1,
+						 pllctl1_mask, pllctl1_val);
+		udelay(1000);
+
+		if (!err)
+			err = regmap_update_bits(regmap, PLLCTL1,
+						 PLLCTL1_CKEN_MASK,
+						 PLLCTL1_CKEN_MASK);
+	}
+
+	return err;
+}
+
+static int tc358746_set_csi_color_space(struct regmap *regmap,
+		u8 pdformat, u8 pdataf)
+{
+	int err;
+
+	err = regmap_update_bits(regmap, DATAFMT,
+				 (DATAFMT_PDFMT_MASK | DATAFMT_UDT_EN_MASK),
+				 DATAFMT_PDFMT_SET(pdformat));
+
+	if (!err)
+		err = regmap_update_bits(regmap, CONFCTL, CONFCTL_PDATAF_MASK,
+					 CONFCTL_PDATAF_SET(pdataf));
+
+	return err;
+}
+
+static int tc358746_set_buffers(struct regmap *regmap,
+		u32 fmt_width, u8 bpp, u16 vb_fifo)
+{
+	unsigned int byte_per_line = (fmt_width * bpp) / 8;
+	int err;
+
+	err = regmap_write(regmap, FIFOCTL, vb_fifo);
+
+	if (!err)
+		err = regmap_write(regmap, WORDCNT, byte_per_line);
+
+	return err;
+}
+
+static int tc358746_enable_csi_lanes(struct regmap *regmap,
+		int lane_num, int enable)
+{
+	u32 val = 0;
+	int err = 0;
+
+	if (lane_num < 1 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, CLW_CNTRL,
+					   CLW_CNTRL_CLW_LANEDISABLE_MASK);
+		if (!err)
+			err = regmap_write(regmap, D0W_CNTRL,
+					   D0W_CNTRL_D0W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 2 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D1W_CNTRL,
+					   D1W_CNTRL_D1W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 3 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D2W_CNTRL,
+					   D2W_CNTRL_D2W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 4 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D3W_CNTRL,
+					   D2W_CNTRL_D3W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num > 0 && enable) {
+		val |= HSTXVREGEN_CLM_HSTXVREGEN_MASK |
+			HSTXVREGEN_D0M_HSTXVREGEN_MASK;
+	}
+
+	if (lane_num > 1 && enable)
+		val |= HSTXVREGEN_D1M_HSTXVREGEN_MASK;
+
+	if (lane_num > 2 && enable)
+		val |= HSTXVREGEN_D2M_HSTXVREGEN_MASK;
+
+	if (lane_num > 3 && enable)
+		val |= HSTXVREGEN_D3M_HSTXVREGEN_MASK;
+
+	if (!err)
+		err = regmap_write(regmap, HSTXVREGEN, val);
+
+	return err;
+}
+
+struct tc358746_csi_param {
+	bool is_continuous_clk;
+
+	/* CSI2-TX Parameters */
+	u32 lineinitcnt;
+	u32 lptxtimecnt;
+	u32 twakeupcnt;
+	u32 tclk_preparecnt;
+	u32 tclk_zerocnt;
+	u32 tclk_trailcnt;
+	u32 tclk_postcnt;
+	u32 ths_preparecnt;
+	u32 ths_zerocnt;
+	u32 ths_trailcnt;
+
+	u32 hstxvregcnt;
+};
+
+static void tc358746_csi_param_set_default(
+		struct tc358746_csi_param *param,
+		bool discontinuous_clk)
+{
+	param->is_continuous_clk = !discontinuous_clk;
+
+	param->lineinitcnt = 4000;
+	param->lptxtimecnt = 3;
+
+	param->tclk_preparecnt = 2;
+	param->tclk_zerocnt = 18;
+
+	/* default, skipped but value in excell = 0 */
+	param->tclk_trailcnt = 1;
+
+	param->ths_preparecnt = 3;
+	param->ths_zerocnt = 0;
+
+	param->twakeupcnt = 17000;
+
+	/* default, skipped but value in excell = 4 */
+	param->tclk_postcnt = 0;
+
+	param->ths_trailcnt = 1;
+
+	/* only presents in the excell, default: 32 */
+	param->hstxvregcnt = 5;
+}
+
+static int tc358746_set_csi(struct regmap *regmap,
+		struct tc358746_csi_param *param)
+{
+	u32 val;
+	int err;
+
+	val = TCLK_HEADERCNT_TCLK_ZEROCNT_SET(param->tclk_zerocnt) |
+	      TCLK_HEADERCNT_TCLK_PREPARECNT_SET(param->tclk_preparecnt);
+	err = regmap_write(regmap, TCLK_HEADERCNT, val);
+
+	val = THS_HEADERCNT_THS_ZEROCNT_SET(param->ths_zerocnt) |
+	      THS_HEADERCNT_THS_PREPARECNT_SET(param->ths_preparecnt);
+	if (!err)
+		err = regmap_write(regmap, THS_HEADERCNT, val);
+
+	if (!err)
+		err = regmap_write(regmap, TWAKEUP, param->twakeupcnt);
+
+	if (!err)
+		err = regmap_write(regmap, TCLK_POSTCNT, param->tclk_postcnt);
+
+	if (!err)
+		err = regmap_write(regmap, THS_TRAILCNT, param->ths_trailcnt);
+
+	if (!err)
+		err = regmap_write(regmap, LINEINITCNT, param->lineinitcnt);
+
+	if (!err)
+		err = regmap_write(regmap, LPTXTIMECNT, param->lptxtimecnt);
+
+	if (!err)
+		err = regmap_write(regmap, TCLK_TRAILCNT, param->tclk_trailcnt);
+
+	if (!err)
+		err = regmap_write(regmap, HSTXVREGCNT, param->hstxvregcnt);
+
+	val = param->is_continuous_clk ? TXOPTIONCNTRL_CONTCLKMODE_MASK : 0;
+	if (!err)
+		err = regmap_write(regmap, TXOPTIONCNTRL, val);
+
+	return err;
+}
+
+static int tc38764_debug_pattern_80(struct regmap *regmap)
+{
+	int i, err;
+
+	err = regmap_write(regmap, DBG_ACT_LINE_CNT, 0x8000);
+	if (!err)
+		err = regmap_write(regmap, DBG_LINE_WIDTH, 0x0821);
+	if (!err)
+		err = regmap_write(regmap, DBG_VERT_BLANK_LINE_CNT, 0);
+
+	/* White 80pixel */
+	for (i = 0; i < 120 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+	}
+
+	/* Yellow 80pixel, BGR: 00 FF FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+	}
+
+	/* Cyan 80pixel, BGR: FF FF 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+	}
+
+	/* Green 80pixel, BGR: 00 FF 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+	}
+
+	/* Magenda 80pixel, BGR: FF 00 FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xffff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+	}
+
+	/* Red 80pixel, BGR: 00 00 FF */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+	}
+
+	/* Blue 80pixel, BGR: FF 00 00 */
+	for (i = 0; i < 40 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x00ff);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0xff00);
+		if (!err)
+			err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+	}
+
+	/* Black 80pixel */
+	for (i = 0; i < 120 && !err; i++) {
+		err = regmap_write(regmap, DBG_VIDEO_DATA, 0x0000);
+	}
+
+	return err;
+}
+
+static int tc358746_wr_csi_control(struct regmap *regmap, u32 val)
+{
+	u32 _val;
+
+	val &= CSI_CONFW_DATA_MASK;
+	_val = CSI_CONFW_MODE_SET_MASK | CSI_CONFW_ADDRESS_CSI_CONTROL_MASK |
+		val;
+
+	return regmap_write(regmap, CSI_CONFW, _val);
+}
+
+static int tc358746_enable_csi_module(struct regmap *regmap, int lane_num)
+{
+	u32 val;
+	int err;
+
+	err = regmap_write(regmap, STARTCNTRL, STARTCNTRL_START_MASK);
+
+	if (!err)
+		err = regmap_write(regmap, CSI_START, CSI_START_STRT_MASK);
+
+	val = CSI_CONTROL_NOL_1_MASK;
+	if (lane_num == 2)
+		val = CSI_CONTROL_NOL_2_MASK;
+	else if (lane_num == 3)
+		val = CSI_CONTROL_NOL_3_MASK;
+	else if (lane_num == 4)
+		val = CSI_CONTROL_NOL_4_MASK;
+
+	val |= CSI_CONTROL_CSI_MODE_MASK | CSI_CONTROL_TXHSMD_MASK |
+		CSI_CONTROL_EOTDIS_MASK; /* add according to excell */
+
+	if (!err)
+		err = tc358746_wr_csi_control(regmap, val);
+
+	return err;
+}
+
+static int dione640_set_mode(struct tegracam_device *tc_dev)
+{
+	struct dione640 *priv = (struct dione640 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	struct regmap *tx_regmap = priv->tx_regmap;
+	int err;
+
+	/* Parameters:
+	 *
+	 * 1. pll setup:
+	 * - pll_prd: Pre Divider value // calc
+	 * - pll_fbd: Multiply value of Unit Clock // calc
+	 * - pll_frs: CSI speed/lane // calc
+	 *
+	 * 2. setup format: RGB888
+	 * - pdformat: 0x3 // dt
+	 * - pdataformat: 0x0 // dt
+	 *
+	 * 3. setup buffers:
+	 * - fmt_width = 640 // dt
+	 * - bpp = 24 (bits per pixel) // dt
+	 * - vb_fifo = 247 (fifo size) // calc
+	 *
+	 * 4. setup csi lanes
+	 * - lane_num = 2 // dt
+	 * - struct tc358746_csi_param // calc
+	 * - discontinuous_clk = true // dt
+	 *
+	 * 5. test_mode
+	 */
+	u16 pll_prd = 3, pll_fbd = 82, pll_frs = 1;
+	u8 pdformat = 0x3, pdataf = 0x0;
+	u32 fmt_width = 640; u8 bpp = 24; u16 vb_fifo = 247;
+	int lane_num = 2;
+	struct tc358746_csi_param csi_setting;
+	bool discontinuous_clk = true;
+
+	tc358746_csi_param_set_default(&csi_setting, discontinuous_clk);
+
+	regmap_write(ctl_regmap, DBG_ACT_LINE_CNT, 0);
+
+	err = tc358746_sreset(ctl_regmap);
+	if (err) {
+		dev_err(tc_dev->dev, "Failed to reset chip\n");
+		return err;
+	}
+
+	err = tc358746_set_pll(ctl_regmap, pll_prd, pll_fbd, pll_frs);
+	if (err) {
+		dev_err(tc_dev->dev, "Failed to setup PLL\n");
+		return err;
+	}
+
+	err = tc358746_set_csi_color_space(ctl_regmap, pdformat, pdataf);
+
+	if (!err)
+		err = tc358746_set_buffers(ctl_regmap, fmt_width, bpp, vb_fifo);
+
+	if (!err)
+		err = tc358746_enable_csi_lanes(tx_regmap, lane_num, true);
+
+	if (!err)
+		err = tc358746_set_csi(tx_regmap, &csi_setting);
+
+	if (!err && test_mode)
+		err = tc38764_debug_pattern_80(ctl_regmap);
+
+	if (!err)
+		err = tc358746_enable_csi_module(tx_regmap, lane_num);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static int dione640_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct dione640 *priv = (struct dione640 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	int err;
+
+	err = regmap_write(ctl_regmap, PP_MISC, 0);
+	if (test_mode) {
+		if (!err)
+			err = regmap_write(ctl_regmap, DBG_ACT_LINE_CNT, 0xc1df);
+	} else {
+		if (!err)
+			err = regmap_update_bits(ctl_regmap, CONFCTL,
+						 CONFCTL_PPEN_MASK,
+						 CONFCTL_PPEN_MASK);
+	}
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static int dione640_stop_streaming(struct tegracam_device *tc_dev)
+{
+	struct dione640 *priv = (struct dione640 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	struct regmap *tx_regmap = priv->tx_regmap;
+	int err;
+
+	err = regmap_update_bits(ctl_regmap, PP_MISC, PP_MISC_FRMSTOP_MASK,
+				 PP_MISC_FRMSTOP_MASK);
+	if (!err)
+		err = regmap_update_bits(ctl_regmap, CONFCTL,
+					 CONFCTL_PPEN_MASK, 0);
+
+	if (!err)
+		err = regmap_update_bits(ctl_regmap, PP_MISC,
+					 PP_MISC_RSTPTR_MASK,
+					 PP_MISC_RSTPTR_MASK);
+
+	if (!err)
+		err = regmap_write(tx_regmap, CSIRESET,
+				   (CSIRESET_RESET_CNF_MASK |
+				    CSIRESET_RESET_MODULE_MASK));
+	if (!err)
+		err = regmap_write(ctl_regmap, DBG_ACT_LINE_CNT, 0);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static struct camera_common_sensor_ops dione640_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(dione640_frmfmt),
+	.frmfmt_table = dione640_frmfmt,
+	.power_on = dione640_power_on,
+	.power_off = dione640_power_off,
+	.write_reg = dione640_write_reg,
+	.read_reg = dione640_read_reg,
+	.parse_dt = dione640_parse_dt,
+	.power_get = dione640_power_get,
+	.power_put = dione640_power_put,
+	.set_mode = dione640_set_mode,
+	.start_streaming = dione640_start_streaming,
+	.stop_streaming = dione640_stop_streaming,
+};
+
+static int dione640_board_setup(struct dione640 *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	struct regmap *ctl_regmap = s_data->regmap;
+	u32 reg_val;
+	int err = 0;
+
+	if (pdata->mclk_name) {
+		err = camera_common_mclk_enable(s_data);
+		if (err) {
+			dev_err(dev, "error turning on mclk (%d)\n", err);
+			goto done;
+		}
+	}
+
+	err = dione640_power_on(s_data);
+	if (err) {
+		dev_err(dev, "error during power on sensor (%d)\n", err);
+		goto err_power_on;
+	}
+
+	/* Probe sensor model id registers */
+	err = regmap_read(ctl_regmap, CHIPID, &reg_val);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+
+	if ((reg_val & CHIPID_CHIPID_MASK) != 0x4400) {
+		dev_err(dev, "%s: invalid sensor model id: %x\n",
+			__func__, reg_val);
+		err = -ENODEV;
+		goto err_reg_probe;
+	}
+
+err_reg_probe:
+	dione640_power_off(s_data);
+
+err_power_on:
+	if (pdata->mclk_name)
+		camera_common_mclk_disable(s_data);
+
+done:
+	return err;
+}
+
+static int dione640_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops dione640_subdev_internal_ops = {
+	.open = dione640_open,
+};
+
+static int dione640_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tegracam_device *tc_dev;
+	struct dione640 *priv;
+	int err;
+
+	dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(dev, sizeof(struct dione640), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return -ENOMEM;
+
+	priv->i2c_client = tc_dev->client = client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "dione64", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &ctl_regmap_config;
+	tc_dev->sensor_ops = &dione640_common_ops;
+	tc_dev->v4l2sd_internal_ops = &dione640_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &dione640_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		dev_err(dev, "tegra camera driver registration failed\n");
+		return err;
+	}
+
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+
+	priv->tx_regmap = devm_regmap_init_i2c(client,
+					       &tx_regmap_config);
+	if (IS_ERR(priv->tx_regmap)) {
+		dev_err(dev, "tx_regmap init failed: %ld\n",
+			PTR_ERR(priv->tx_regmap));
+		tegracam_device_unregister(tc_dev);
+		return -ENODEV;
+	}
+
+	err = dione640_board_setup(priv);
+	if (err) {
+		tegracam_device_unregister(tc_dev);
+		dev_err(dev, "board setup failed\n");
+		return err;
+	}
+
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
+		tegracam_device_unregister(tc_dev);
+		return err;
+	}
+
+	dev_info(dev, "detected dione640 sensor\n");
+
+	return 0;
+}
+
+static int dione640_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct dione640 *priv = (struct dione640 *)s_data->priv;
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id dione640_id[] = {
+	{ "dione64", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, dione640_id);
+
+static struct i2c_driver dione640_i2c_driver = {
+	.driver = {
+		.name = "dione64",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(dione640_of_match),
+	},
+	.probe = dione640_probe,
+	.remove = dione640_remove,
+	.id_table = dione640_id,
+};
+module_i2c_driver(dione640_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Xenics Dione640");
+MODULE_AUTHOR("Xenics Infrared Solutions / Peter Rozsahegyi");
+MODULE_LICENSE("GPL v2");
diff --git a/nvidia/drivers/media/i2c/tc358746_regs.h b/nvidia/drivers/media/i2c/tc358746_regs.h
new file mode 100644
index 000000000000..9232d00d0e92
--- /dev/null
+++ b/nvidia/drivers/media/i2c/tc358746_regs.h
@@ -0,0 +1,208 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * tc358746 - Toshiba Parallel to CSI-2 bridge - register names and bit masks
+ *
+ * Convention:
+ * <REGISTER>
+ * <REGISTER>_<BITFIELD>_MASK
+ * <REGISTER>_<BITFIELD>_<VALUE>
+ * <REGISTER>_<BITFIELD>_SET(val = <REGISTER>_<BITFIELD>_<VALUE>)
+ *
+ * References:
+ * REF_01:
+ * - TC358746AXBG/TC358748XBG/TC358748IXBG Functional Specification Rev 1.2
+ */
+
+#ifndef __TC358746_REGS_H
+#define __TC358746_REGS_H
+
+#define CHIPID			0x0000
+#define CHIPID_CHIPID_MASK		GENMASK(15, 8)
+#define CHIPID_REVID_MASK		GENMASK(7, 0)
+
+#define SYSCTL			0x0002
+#define SYSCTL_SLEEP_MASK		BIT(1)
+#define SYSCTL_SRESET_MASK		BIT(0)
+
+#define CONFCTL                 0x0004
+#define CONFCTL_TRIEN_MASK		BIT(15)
+#define CONFCTL_INTE2N_MASK		BIT(13)
+#define CONFCTL_BT656EN_MASK		BIT(12)
+#define CONFCTL_PDATAF_MASK		GENMASK(9, 8)
+#define CONFCTL_PDATAF_SET(val)		(((val << 8) & CONFCTL_PDATAF_MASK))
+#define CONFCTL_PDATAF_MODE0		0
+#define CONFCTL_PDATAF_MODE1		1
+#define CONFCTL_PDATAF_MODE2		2
+#define CONFCTL_PPEN_MASK		BIT(6)
+#define CONFCTL_VVALIDP_MASK		BIT(5)
+#define CONFCTL_HVALIDP_MASK		BIT(4)
+#define CONFCTL_PCLKP_MASK		BIT(3)
+#define CONFCTL_AUTO_MASK		BIT(2)
+#define CONFCTL_DATALANE_MASK		GENMASK(1, 0)
+#define CONFCTL_DATALANE_1		0
+#define CONFCTL_DATALANE_2		1
+#define CONFCTL_DATALANE_3		2
+#define CONFCTL_DATALANE_4		3
+
+#define FIFOCTL			0x0006
+#define DATAFMT			0x0008
+#define DATAFMT_PDFMT_RAW8		0
+#define DATAFMT_PDFMT_RAW10		1
+#define DATAFMT_PDFMT_RAW12		2
+#define DATAFMT_PDFMT_RGB888		3
+#define DATAFMT_PDFMT_RGB666		4
+#define DATAFMT_PDFMT_RGB565		5
+#define DATAFMT_PDFMT_YCBCRFMT_422_8_BIT 6
+#define DATAFMT_PDFMT_RAW14		8
+#define DATAFMT_PDFMT_YCBCRFMT_422_10_BIT 9
+#define DATAFMT_PDFMT_YCBCRFMT_444	10
+#define DATAFMT_PDFMT_MASK		GENMASK(7, 4)
+#define DATAFMT_PDFMT_SET(val)		(((val) << 4) & DATAFMT_PDFMT_MASK)
+#define DATAFMT_UDT_EN_MASK		BIT(0)
+
+#define MCLKCTL			0x000c
+#define MCLKCTL_MCLK_HIGH_MASK		GENMASK(15, 8)
+#define MCLKCTL_MCLK_HIGH_SET(val)	((((val) - 1) << 8) & MCLKCTL_MCLK_HIGH_MASK)
+#define MCLKCTL_MCLK_LOW_MASK		GENMASK(7, 0)
+#define MCLKCTL_MCLK_LOW_SET(val)	(((val) - 1) & MCLKCTL_MCLK_LOW_MASK)
+
+#define PLLCTL0			0x0016
+#define PLLCTL0_PLL_PRD_MASK		GENMASK(15, 12)
+#define PLLCTL0_PLL_PRD_SET(prd)	((((prd) - 1) << 12) & PLLCTL0_PLL_PRD_MASK)
+#define PLLCTL0_PLL_FBD_MASK		GENMASK(8, 0)
+#define PLLCTL0_PLL_FBD_SET(fbd)        (((fbd) - 1) & PLLCTL0_PLL_FBD_MASK)
+
+#define PLLCTL1                 0x0018
+#define PLLCTL1_PLL_FRS_MASK            GENMASK(11, 10)
+#define PLLCTL1_PLL_FRS_SET(frs)        (((frs) << 10) & PLLCTL1_PLL_FRS_MASK)
+#define PLLCTL1_PLL_LBWS_MASK		GENMASK(9, 8)
+#define PLLCTL1_LFBREN_MASK		BIT(6)
+#define PLLCTL1_BYPCKEN_MASK		BIT(5)
+#define PLLCTL1_CKEN_MASK		BIT(4)
+#define PLLCTL1_RESETB_MASK		BIT(1)
+#define PLLCTL1_PLL_EN_MASK		BIT(0)
+
+#define CLKCTL			0x0020
+#define CLKCTL_MCLKDIV_MASK		GENMASK(3, 2)
+#define CLKCTL_MCLKDIV_SET(val)		((val << 2) & CLKCTL_MCLKDIV_MASK)
+#define CLKCTL_MCLKDIV_8		0
+#define CLKCTL_MCLKDIV_4		1
+#define CLKCTL_MCLKDIV_2		2
+
+#define WORDCNT			0x0022
+#define PP_MISC                 0x0032
+#define PP_MISC_FRMSTOP_MASK		BIT(15)
+#define PP_MISC_RSTPTR_MASK		BIT(14)
+
+#define CSI2TX_DATA_TYPE	0x0050
+#define MIPI_PHY_STATUS		0x0062
+#define CSI2_ERROR_STATUS       0x0064
+#define CSI2_ERR_EN             0x0066
+#define CSI2_IDID_ERROR         0x006c
+#define DBG_ACT_LINE_CNT        0x00e0
+#define DBG_LINE_WIDTH		0x00e2
+#define DBG_VERT_BLANK_LINE_CNT	0x00e4
+#define DBG_VIDEO_DATA          0x00e8
+#define FIFOSTATUS              0x00F8
+
+#define CLW_CNTRL               0x0140
+#define CLW_CNTRL_CLW_LANEDISABLE_MASK	BIT(0)
+
+#define D0W_CNTRL               0x0144
+#define D0W_CNTRL_D0W_LANEDISABLE_MASK	BIT(0)
+
+#define D1W_CNTRL		0x0148
+#define D1W_CNTRL_D1W_LANEDISABLE_MASK	BIT(0)
+
+#define D2W_CNTRL		0x014C
+#define D2W_CNTRL_D2W_LANEDISABLE_MASK	BIT(0)
+
+#define D3W_CNTRL		0x0150
+#define D2W_CNTRL_D3W_LANEDISABLE_MASK	BIT(0)
+
+#define STARTCNTRL              0x0204
+#define STARTCNTRL_START_MASK		BIT(0)
+
+#define LINEINITCNT		0x0210
+#define LPTXTIMECNT		0x0214
+#define TCLK_HEADERCNT		0x0218
+#define	TCLK_HEADERCNT_TCLK_ZEROCNT_MASK	GENMASK(15, 8)
+#define TCLK_HEADERCNT_TCLK_PREPARECNT_MASK	GENMASK(6, 0)
+#define	TCLK_HEADERCNT_TCLK_ZEROCNT_SET(val)	((val << 8) & TCLK_HEADERCNT_TCLK_ZEROCNT_MASK)
+#define	TCLK_HEADERCNT_TCLK_PREPARECNT_SET(val)	(val & TCLK_HEADERCNT_TCLK_PREPARECNT_MASK)
+
+#define TCLK_TRAILCNT		0x021C
+#define THS_HEADERCNT		0x0220
+#define	THS_HEADERCNT_THS_ZEROCNT_MASK		GENMASK(14, 8)
+#define	THS_HEADERCNT_THS_PREPARECNT_MASK	GENMASK(6, 0)
+#define	THS_HEADERCNT_THS_ZEROCNT_SET(val)	((val << 8) & THS_HEADERCNT_THS_ZEROCNT_MASK)
+#define	THS_HEADERCNT_THS_PREPARECNT_SET(val)	(val & THS_HEADERCNT_THS_PREPARECNT_MASK)
+
+#define TWAKEUP			0x0224
+#define TCLK_POSTCNT		0x0228
+#define THS_TRAILCNT		0x022C
+#define HSTXVREGCNT		0x0230
+#define HSTXVREGEN              0x0234
+#define HSTXVREGEN_D3M_HSTXVREGEN_MASK	BIT(4)
+#define HSTXVREGEN_D2M_HSTXVREGEN_MASK  BIT(3)
+#define HSTXVREGEN_D1M_HSTXVREGEN_MASK  BIT(2)
+#define HSTXVREGEN_D0M_HSTXVREGEN_MASK  BIT(1)
+#define HSTXVREGEN_CLM_HSTXVREGEN_MASK  BIT(0)
+
+#define TXOPTIONCNTRL           0x0238
+#define TXOPTIONCNTRL_CONTCLKMODE_MASK	BIT(0)
+
+#define CSI_CONTROL             0x040C
+#define CSI_CONTROL_CSI_MODE_MASK       BIT(15)
+#define CSI_CONTROL_HTXTOEN_MASK        BIT(10)
+#define CSI_CONTROL_TXHSMD_MASK         BIT(7)
+#define CSI_CONTROL_NOL_MASK            GENMASK(2, 1)
+#define CSI_CONTROL_NOL_1_MASK          0
+#define CSI_CONTROL_NOL_2_MASK          BIT(1)
+#define CSI_CONTROL_NOL_3_MASK          BIT(2)
+#define CSI_CONTROL_NOL_4_MASK          (BIT(1) | BIT(2))
+#define CSI_CONTROL_EOTDIS_MASK         BIT(0)
+
+#define CSI_STATUS              0x0410
+#define CSI_STATUS_S_WSYNC_MASK		BIT(10)
+#define CSI_STATUS_S_TXACT_MASK		BIT(9)
+#define CSI_STATUS_S_HLT_MASK		BIT(0)
+
+#define CSI_INT			0x0414
+#define CSI_INT_INTHLT_MASK		BIT(3)
+#define CSI_INT_INTER_MASK		BIT(2)
+
+#define CSI_INT_ENA             0x0418
+#define CSI_INT_ENA_IENHLT_MASK		BIT(3)
+#define CSI_INT_ENA_IENER_MASK		BIT(2)
+
+#define CSI_ERR                 0x044C
+#define CSI_ERR_INER_MASK               BIT(9)
+#define CSI_ERR_WCER_MASK		BIT(8)
+#define CSI_ERR_QUNK_MASK		BIT(4)
+#define CSI_ERR_TXBRK_MASK		BIT(1)
+
+#define CSI_ERR_INTENA          0x0450
+#define CSI_ERR_HALT            0x0454
+#define CSI_CONFW               0x0500
+#define CSI_CONFW_MODE_MASK			GENMASK(31, 29)
+#define CSI_CONFW_MODE_SET_MASK			(BIT(31) | BIT(29))
+#define CSI_CONFW_MODE_CLEAR_MASK		(BIT(31) | BIT(30))
+#define CSI_CONFW_ADDRESS_MASK			GENMASK(28, 24)
+#define CSI_CONFW_ADDRESS_CSI_CONTROL_MASK	(BIT(24) | BIT(25))
+#define CSI_CONFW_ADDRESS_CSI_INT_ENA_MASK	(BIT(25) | BIT(26))
+#define CSI_CONFW_ADDRESS_CSI_ERR_INTENA_MASK	(BIT(28) | BIT(26))
+#define CSI_CONFW_ADDRESS_CSI_ERR_HALT_MASK	(BIT(28) | BIT(26) | BIT(24))
+#define CSI_CONFW_DATA_MASK			GENMASK(15, 0)
+
+#define CSIRESET                0x0504
+#define CSIRESET_RESET_CNF_MASK		BIT(1)
+#define CSIRESET_RESET_MODULE_MASK	BIT(0)
+
+#define CSI_INT_CLR             0x050C
+#define CSI_INT_CLR_ICRER_MASK		BIT(2)
+
+#define CSI_START               0x0518
+#define CSI_START_STRT_MASK		BIT(0)
+
+#endif
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione640.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione640.dtsi
new file mode 100644
index 000000000000..56ad44c52685
--- /dev/null
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione640.dtsi
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) 2021, Xenics Infrared Solutions.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <dt-bindings/media/camera.h>
+#include <dt-bindings/platform/t210/t210.h>
+
+/ {
+	host1x {
+		vi_base: vi {
+			num-channels = <1>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				vi_port0: port@0 {
+					reg = <0>;
+					rbpcv2_dione640_vi_in0: endpoint {
+						port-index = <0>;
+						bus-width = <2>;
+						remote-endpoint = <&rbpcv2_dione640_csi_out0>;
+					};
+				};
+			};
+		};
+
+		csi_base: nvcsi {
+			num-channels = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			csi_chan0: channel@0 {
+				reg = <0>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan0_port0: port@0 {
+						reg = <0>;
+						rbpcv2_dione640_csi_in0: endpoint@0 {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_dione640_out0>;
+						};
+					};
+					csi_chan0_port1: port@1 {
+						reg = <1>;
+						rbpcv2_dione640_csi_out0: endpoint@1 {
+							remote-endpoint = <&rbpcv2_dione640_vi_in0>;
+						};
+					};
+				};
+			};
+		};
+
+		i2c@546c0000 {
+			dione640_single_cam0: rbpcv2_dione640_a@0e {
+				compatible = "xenics,dione64";
+				/* I2C device address */
+				reg = <0x0e>;
+
+				/* V4L2 device node location */
+				devnode = "video0";
+
+				/* Physical dimensions of sensor */
+				physical_w = "7.680";
+				physical_h = "5.760";
+
+				sensor_model = "dione640";
+
+				use_sensor_mode_id = "true";
+
+				/**
+				* ==== Modes ====
+				* A modeX node is required to support v4l2 driver
+				* implementation with NVIDIA camera software stack
+				*
+				* == Signal properties ==
+				*
+				* phy_mode = "";
+				* PHY mode used by the MIPI lanes for this device
+				*
+				* tegra_sinterface = "";
+				* CSI Serial interface connected to tegra
+				* Incase of virtual HW devices, use virtual
+				* For SW emulated devices, use host
+				*
+				* pix_clk_hz = "";
+				* Sensor pixel clock used for calculations like exposure and framerate
+				*
+				* readout_orientation = "0";
+				* Based on camera module orientation.
+				* Only change readout_orientation if you specifically
+				* Program a different readout order for this mode
+				*
+				* == Image format Properties ==
+				*
+				* active_w = "";
+				* Pixel active region width
+				*
+				* active_h = "";
+				* Pixel active region height
+				*
+				* pixel_t = "";
+				* The sensor readout pixel pattern
+				*
+				* line_length = "";
+				* Pixel line length (width) for sensor mode.
+				*
+				* == Source Control Settings ==
+				*
+				* Gain factor used to convert fixed point integer to float
+				* Gain range [min_gain/gain_factor, max_gain/gain_factor]
+				* Gain step [step_gain/gain_factor is the smallest step that can be configured]
+				* Default gain [Default gain to be initialized for the control.
+				*     use min_gain_val as default for optimal results]
+				* Framerate factor used to convert fixed point integer to float
+				* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
+				* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
+				* Default Framerate [Default framerate to be initialized for the control.
+				*     use max_framerate to get required performance]
+				* Exposure factor used to convert fixed point integer to float
+				* For convenience use 1 sec = 1000000us as conversion factor
+				* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
+				* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
+				* Default Exposure Time [Default exposure to be initialized for the control.
+				*     Set default exposure based on the default_framerate for optimal exposure settings]
+				*
+				* gain_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_gain_val = ""; (ceil to integer)
+				* max_gain_val = ""; (ceil to integer)
+				* step_gain_val = ""; (ceil to integer)
+				* default_gain = ""; (ceil to integer)
+				* Gain limits for mode
+				*
+				* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_exp_time = ""; (ceil to integer)
+				* max_exp_time = ""; (ceil to integer)
+				* step_exp_time = ""; (ceil to integer)
+				* default_exp_time = ""; (ceil to integer)
+				* Exposure Time limits for mode (sec)
+				*
+				* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_framerate = ""; (ceil to integer)
+				* max_framerate = ""; (ceil to integer)
+				* step_framerate = ""; (ceil to integer)
+				* default_framerate = ""; (ceil to integer)
+				* Framerate limits for mode (fps)
+				*
+				* embedded_metadata_height = "";
+				* Sensor embedded metadata height in units of rows.
+				* If sensor does not support embedded metadata value should be 0.
+				*/
+				mode0 { /* DIONE640_MODE_640x480_60FPS */
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_a";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes";
+					dpcm_enable = "false";
+					cil_settletime = "0";
+
+					active_w = "640";
+					active_h = "480";
+					pixel_t = "rgb_rgb88824";
+					readout_orientation = "0";
+					line_length = "694";
+					/* inherent_gain = "1"; */
+					/* mclk_multiplier = "9.33"; */
+					pix_clk_hz = "20000000";
+
+					/* unused */
+					gain_factor = "16";
+					exposure_factor = "1000000";
+					min_gain_val = "16"; /* 1.00x */
+					max_gain_val = "170"; /* 10.66x */
+					step_gain_val = "1";
+					default_gain = "16"; /* 1.00x */
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+
+					/* framerate */
+					framerate_factor = "1000000";
+					min_framerate = "40000000"; /* 40 fps */
+					max_framerate = "62000000"; /* 62 fps */
+					step_framerate = "1";
+					default_framerate = "60020000"; /* 60.020 fps */
+
+					/* unused */
+					min_exp_time = "13"; /* us */
+					max_exp_time = "683709"; /* us */
+					step_exp_time = "1";
+					default_exp_time = "2495"; /* us */
+
+					embedded_metadata_height = "0";
+				};
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						rbpcv2_dione640_out0: endpoint {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_dione640_csi_in0>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	/* CN 3423-xx SN xxxx 55mm F/1 */
+	lens_dione640@RBPCV2 {
+		min_focus_distance = "2000.0"; /* F.R 2m ~ ... */
+		hyper_focal = "0.0";
+		focal_length = "55.0"; /* E.F.L 55mm */
+		f_number = "1.0"; /* F.NO 1.0 */
+		aperture = "0.0";
+	};
+};
+
+/ {
+	tcp: tegra-camera-platform {
+		compatible = "nvidia, tegra-camera-platform";
+
+		/**
+		* Physical settings to calculate max ISO BW
+		*
+		* num_csi_lanes = <>;
+		* Total number of CSI lanes when all cameras are active
+		*
+		* max_lane_speed = <>;
+		* Max lane speed in Kbit/s
+		*
+		* min_bits_per_pixel = <>;
+		* Min bits per pixel
+		*
+		* vi_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the VI ISO case
+		*
+		* vi_bw_margin_pct = <>;
+		* Vi bandwidth margin in percentage
+		*
+		* max_pixel_rate = <>;
+		* Max pixel rate in Kpixel/s for the ISP ISO case
+		*
+		* isp_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the ISP ISO case
+		*
+		* isp_bw_margin_pct = <>;
+		* Isp bandwidth margin in percentage
+		*/
+		num_csi_lanes = <2>;
+		max_lane_speed = <1500000>;
+		min_bits_per_pixel = <10>;
+		vi_peak_byte_per_pixel = <2>;
+		vi_bw_margin_pct = <25>;
+		max_pixel_rate = <240000>;
+		isp_peak_byte_per_pixel = <5>;
+		isp_bw_margin_pct = <25>;
+
+		/**
+		 * The general guideline for naming badge_info contains 3 parts, and is as follows,
+		 * The first part is the camera_board_id for the module; if the module is in a FFD
+		 * platform, then use the platform name for this part.
+		 * The second part contains the position of the module, ex. "rear" or "front".
+		 * The third part contains the last 6 characters of a part number which is found
+		 * in the module's specsheet from the vendor.
+		 */
+		modules {
+			cam_module0: module0 {
+				badge = "porg_front_RBPCV2";
+				position = "front";
+				orientation = "1";
+				cam_module0_drivernode0: drivernode0 {
+					pcl_id = "v4l2_sensor";
+					devname = "dione64 6-000e";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione640_a@0e";
+				};
+				cam_module0_drivernode1: drivernode1 {
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_dione640@RBPCV2/";
+				};
+			};
+		};
+	};
+};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi
new file mode 100644
index 000000000000..296e1d2c8eae
--- /dev/null
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2018-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "tegra210-camera-rbpcv2-dione640.dtsi"
+
+#define CAM1_PWDN		TEGRA_GPIO(S, 7)
+
+/ {
+    host1x {
+		i2c@546c0000 {
+			rbpcv2_dione640_a@0e {
+				status = "disabled";
+				reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+
+    gpio@6000d000 {
+		camera-control-output-low {
+			gpio-hog;
+			output-low;
+			gpios = < CAM1_PWDN 0 >;
+			label = "cam1-pwdn";
+		};
+	};
+};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
index 74196e10d0db..ac3997cde550 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
@@ -15,7 +15,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #include "tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
-#include "tegra210-porg-camera-rbpcv2-imx219.dtsi"
+#include "tegra210-porg-camera-rbpcv2-dione640.dtsi"
 
 / {
 	tegra-camera-platform {
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
index 93ec6e3876f4..dd19f0c5de26 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
@@ -185,9 +185,9 @@
 					non-removable;
 				};
 			};
-			/* IMX219 single sensor module */
+			/* dione640 single sensor module */
 			override@2 {
-				target = <&imx219_single_cam0>;
+				target = <&dione640_single_cam0>;
 				_overlay_ {
 					status = "okay";
 				};
@@ -206,8 +206,8 @@
 				_overlay_ {
 					status = "okay";
 					pcl_id = "v4l2_sensor";
-					devname = "imx219 6-0010";
-					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_imx219_a@10";
+					devname = "dione64 6-000e";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione640_a@0e";
 				};
 			};
 			override@5 {
@@ -215,7 +215,7 @@
 				_overlay_ {
 					status = "okay";
 					pcl_id = "v4l2_lens";
-					proc-device-tree = "/proc/device-tree/lens_imx219@RBPCV2/";
+					proc-device-tree = "/proc/device-tree/lens_dione640@RBPCV2/";
 				};
 			};
 			/* Enable VI ports */
@@ -232,12 +232,12 @@
 				};
 			};
 			override@8 {
-				target = <&rbpcv2_imx219_vi_in0>;
+				target = <&rbpcv2_dione640_vi_in0>;
 				_overlay_ {
 					status = "okay";
 					port-index = <0>;
 					bus-width = <2>;
-					remote-endpoint = <&rbpcv2_imx219_csi_out0>;
+					remote-endpoint = <&rbpcv2_dione640_csi_out0>;
 				};
 			};
 			/* Enable CSI ports */
@@ -260,12 +260,12 @@
 				};
 			};
 			override@12 {
-				target = <&rbpcv2_imx219_csi_in0>;
+				target = <&rbpcv2_dione640_csi_in0>;
 				_overlay_ {
 					status = "okay";
 					port-index = <0>;
 					bus-width = <2>;
-					remote-endpoint = <&rbpcv2_imx219_out0>;
+					remote-endpoint = <&rbpcv2_dione640_out0>;
 				};
 			};
 			override@13 {
@@ -275,10 +275,10 @@
 				};
 			};
 			override@14 {
-				target = <&rbpcv2_imx219_csi_out0>;
+				target = <&rbpcv2_dione640_csi_out0>;
 				_overlay_ {
 					status = "okay";
-					remote-endpoint = <&rbpcv2_imx219_vi_in0>;
+					remote-endpoint = <&rbpcv2_dione640_vi_in0>;
 				};
 			};
 			/* tegra-camera-platform settings */
diff --git a/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi b/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
index 2a7d84445089..e7dc55b5bbfb 100644
--- a/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
@@ -28,7 +28,7 @@
 #include "porg-platforms/tegra210-pinmux-drive-sdmmc-common.dtsi"
 #include "porg-platforms/tegra210-porg-pwm-fan.dtsi"
 #include "porg-platforms/tegra210-porg-camera.dtsi"
-#include "porg-platforms/tegra210-porg-camera-rbpcv2-imx219.dtsi"
+#include "porg-platforms/tegra210-porg-camera-rbpcv2-dione640.dtsi"
 #include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
 #include <t210-common-platforms/tegra210-ers-hdmi-e2190-1100-a00.dtsi>
 #include <t210-common-platforms/tegra210-dp.dtsi>
